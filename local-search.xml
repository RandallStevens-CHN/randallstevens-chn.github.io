<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 泛型</title>
    <link href="/2022/03/15/Java%20%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/03/15/Java%20%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p><strong>泛型是指将数据类型参数化，在使用时指定具体的类型，使得编译器可以进行安全检查，保证类型安全</strong></p><p>tip: 泛型不支持基本数据类型.</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><blockquote><p>在实例化类时指定具体类型</p><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java">class 类名 &lt;T，E，...&gt; &#123;<br>   <span class="hljs-keyword">private</span> T  变量名;<br>   <span class="hljs-keyword">public</span>  T  <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;;   <span class="hljs-comment">//此处不为泛型方法!!!</span><br>   <span class="hljs-keyword">public</span>  String  <span class="hljs-title function_">show</span><span class="hljs-params">(T type)</span>&#123;&#125;;  <br>   ....<br>&#125;<br><br><span class="hljs-comment">//常用泛型标识符：T,E,K,V   Class&lt;T&gt;类</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T type;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGeneric</span><span class="hljs-params">(T type)</span>&#123;<br>        <span class="hljs-built_in">this</span>.type=type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T  <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.type);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>.type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         Test&lt;String&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>         test.setGeneric(<span class="hljs-string">&quot;hello&quot;</span>);<br>         test.show();<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>特殊的泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个特殊的泛型类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt;&#123;&#125;   <span class="hljs-comment">//Class是一个可以诠释所有类的类，传入是&lt;Test.class&gt;</span><br><br><span class="hljs-comment">//泛型类派生子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildGereric</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneriic</span>&lt;T&gt;     <span class="hljs-comment">//父子类均为泛型类，则父子类的泛型类型必须相同</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildGereric</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneriic</span>&lt;String&gt;   <span class="hljs-comment">//子类不是泛型类，则父类泛型必须明确</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><blockquote><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;interface 接口名称 &lt;T，E，…&gt; &#123;<br>T <span class="hljs-title function_">method1</span><span class="hljs-params">(E elem)</span>; <br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//实现类为泛型类，则泛型类的泛型类型必须包括接口中所有的泛型类型</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T,E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;<br>&gt;<span class="hljs-comment">//实现类不为泛型类，则接口必须明确泛型类型</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><blockquote><p>调用方法时指定泛型的具体类型</p><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-keyword">public</span> &lt;T，E, ...&gt; T 方法名(E... elem) &#123;&#125;   <span class="hljs-comment">//泛型类中泛型与泛型方法中泛型独立，即使名字相同</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt;<span class="hljs-comment">//普通泛型方法</span><br>&gt;<span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(E... e)</span>&#123; <span class="hljs-comment">//传入可变参数  e会作为一个数组</span><br><span class="hljs-keyword">for</span> (E e1 : e) &#123;<br>System.out.println(e);<br>&#125;<br>&gt;&#125;<br>&gt;<span class="hljs-comment">//静态泛型方法</span><br>&gt;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(E... e)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><blockquote><p><strong>数据类型参数化，参数实参化</strong></p><ul><li>泛型类型通配符使用”?”代指类型实参**</li></ul><ul><li><T> 类型形参（或直接叫泛型）；<String>类型实参（泛型的类型）</li></ul><ul><li>类型通配符是类型实参，而不是类型形参   </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>&lt;T&gt;&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">UseA</span>&#123;<br>  <br>    <span class="hljs-keyword">public</span> staic <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(A&lt;?&gt; a)</span>&#123;    <span class="hljs-comment">//此处的参数已经使用实例化a,必须指定泛型类型实参，通过？代指所有类型实参</span><br>      a.method();<br>   &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args )</span>&#123;<br>        A&lt;String&gt;  a1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;<br>        A&lt;Interger&gt; a2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;<br>        UseA.use(a1);<br>        UseA.use(a2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限"></a>类型通配符上限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类/接口&lt;? extends T&gt;     指定实参类型上限</span><br><span class="hljs-comment">// 要求该泛型的类型，只能是T或其子类</span><br>class &lt;？<span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;   <br><span class="hljs-comment">//上述例子</span><br>  <span class="hljs-keyword">public</span> staic <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(A&lt;？extends Number&gt;  a)</span>&#123;    <br>      a.method();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限"></a>类型通配符下限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类/接口&lt;? super T&gt;</span><br><span class="hljs-comment">//要求该泛型的类型，只能是T或其子类</span><br>class &lt;？ <span class="hljs-built_in">super</span> father&gt;   <br><span class="hljs-comment">//可传入的参数（father）/(son)</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><blockquote><p><strong>即泛型在编译期间会被编译器擦除，字节码中是没有泛型的.</strong></p><p><strong>擦除规则</strong>：</p><ul><li>若泛型类型没有指定具体类型，用Object作为原始类型；</li><li>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；</li><li>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型.</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2022/03/15/maven/"/>
    <url>/2022/03/15/maven/</url>
    
    <content type="html"><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Maven是一个专业化的项目管理工具.</strong> </p><ul><li><p>它将项目的开发和管理过程抽象成一个项目对象模型（POM）进行管理</p></li><li><p> 通过pom.xml来进行项目的配置和管理</p></li></ul><p><strong>Maven的作用</strong></p><ul><li>项目构建:  提供标准的，跨平台的自动化项目构建方式</li><li>依赖管理:  方便快捷管理项目的依赖资源（jar包），解决版本冲突</li><li>统一开发结构: 制定了统一标准的项目结构</li></ul><p><strong>Maven的下载安装</strong></p><ol><li>   Apache官网下载</li><li>  解压即可（maven依赖于java 环境）</li><li> 配置环境变量</li></ol><h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1.Basic"></a>1.Basic</h2><blockquote><p><strong>仓库</strong>：存放jar包资源的地方.</p><p>​          分类：1. 本地仓库      2.远程仓库：私服，中心仓库</p><p><strong>坐标</strong>：唯一的对依赖进行标识</p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml">&lt; <span class="hljs-comment">&lt;!-- 示例 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hbase-examples<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>镜像,仓库配置</strong>：maven默认的中央仓库在国外，下载速度慢，故需要配置镜像来加速下载.</p><p>​          进入maven安装目录下的conf/setting.xml </p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 阿里云mirrors  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;&gt;<span class="hljs-comment">&lt;!--  本地仓库配置 --&gt;</span>  <br>&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\JavaEE\maven repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>依赖管理</strong></p><ul><li>依赖具有传递性</li><li>依赖冲突解决：不同层，层级越深，优先级高；同层先声明的优先级高</li><li>可选依赖</li></ul><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <span class="hljs-comment">&lt;!--  依赖对外隐藏 --&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><ul><li>依赖排除</li></ul><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.struts<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>struts2-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;struts.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-comment">&lt;!--  不下载使用该依赖中的部分 --&gt;</span>      <br>               <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>  <br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure></blockquote></blockquote><p>​    </p><h2 id="2-Feature"><a href="#2-Feature" class="headerlink" title="2.Feature"></a><strong>2.Feature</strong></h2><blockquote><p><strong>生命周期</strong>：对于项目的构建过程，Maven 抽象出了一个适合于所有项目的标准，并将它们统一规范。称之为生命周期.</p><blockquote><ul><li><p>项目的构建具体步骤包括清理、初始化、编译、测试、打包、集成测试、验证、部署和生成站点。这些步骤几乎适合所有的项目，即所有项目的管理构建过程都可以对应到这个生命周期上来.</p></li><li><p>Maven 的生命周期只是制定了标准，具体实现由maven的插件来完成的.</p></li><li><p><strong>生命周期的阶段</strong>: Maven拥有三套独立的生命周期，它们分别是 clean、default 和 site。</p></li></ul></blockquote><p>1.clean 生命周期的目的是清理项目；</p><blockquote><blockquote><table><thead><tr><th><strong>阶段</strong></th><th>说明</th></tr></thead><tbody><tr><td>pre-clean</td><td>执行清理前需要完成的工作</td></tr><tr><td>clean</td><td>清理构建生成的文件</td></tr><tr><td>post-clean</td><td>执行清理后需要完成的工作</td></tr></tbody></table></blockquote></blockquote><p> 2.default 生命周期的目的是构建项目；default 是生命周期的核心周期。步骤比较多，下表只列出了核心的一段.其他部分可查看.  <a href="http://c.biancheng.net/view/4899.html">maven生命周期</a></p><blockquote><blockquote><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>compile</td><td>编译项目的源代码</td></tr><tr><td>install</td><td>将包安装至本地仓库，以让其它项目依赖</td></tr><tr><td>deploy</td><td>将最终的包复制到远程的仓库，以让其它开发人员与项目共享</td></tr><tr><td>test</td><td>使用合适的单元测试框架运行测试。</td></tr><tr><td>test-compile</td><td>编译测试源代码</td></tr><tr><td>package</td><td>接收编译好的代码，打包成可发布的格式，如 JAR</td></tr></tbody></table></blockquote></blockquote><p>3.site 生命周期的目的是建立项目站点。</p><blockquote><blockquote><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>pre-site</td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td>site</td><td>生成项目的站点文档</td></tr><tr><td>post-site</td><td>执行生成站点后需要收尾的工作</td></tr><tr><td>site-deploy</td><td>将生成的站点发布到服务器上</td></tr></tbody></table></blockquote></blockquote><p><strong>模块聚合与继承</strong></p><blockquote><p><strong>聚合</strong>：新建一个maven项目；  在此项目基础上新建maven模块,在父项目的pom.xml中通过<moudle>来指定子模块<br><strong>继承</strong>：子模块通过<parent> 继承父模块，且模块间的依赖也会继承，继承会将一切继承包括插件，设置等全部<br><strong>所要进行聚合的父项目和所要被继承的父项目可以不是同一个（一般设置为同一个）！！！！！！</strong>                                             父项目一般只用来模块设计（聚合），一般删除src文件夹；打包方式为pom。<br>聚合中父项目是有感知，子模块无感知，即子模块认为自己是一个独立的项目<br>继承中被继承的模块是无感知的，主动继承的是有感知的<br><strong>项目结构示例</strong>：<br><img src="/img/post_img/maven_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"><br><strong>依赖关系示例</strong>：<br>​      <strong>父项目依赖druid,   project_Dao依赖spring-beans, 而project_Service依赖于模块Dao,</strong><br><img src="/img/post_img/maven_%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt=" ">      </p></blockquote><p>​    </p><p><strong>POM属性</strong>：</p><blockquote><p>Maven中支持属性类型<br>​     自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <span class="hljs-comment">&lt;!--自定义属性  --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-comment">&lt;!--调用属性  --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br></code></pre></td></tr></table></figure><p>​      内置属性：如 $<version>该项目版本变量<br>​                     $&lt;base.dir&gt;    该项目根路径变量 等<br>​      setting属性：用于动态获取maven的setting.xml中信息如 ${settings.localRepository}<br>​      系统属性：读取java相关系统属性属性和系统环境变量属性. 如​{env.JAVA_HOME}，也可通过 maven命令查看：mvn  help:system</p></blockquote><p><strong>其他特性</strong></p><p>​     <strong>资源配置，资源过滤，私服搭建等</strong></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称/非对称加密方式</title>
    <link href="/2022/03/13/%E5%AF%B9%E7%A7%B0/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/03/13/%E5%AF%B9%E7%A7%B0/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="对称-非对称加密方式"><a href="#对称-非对称加密方式" class="headerlink" title="对称/非对称加密方式"></a>对称/非对称加密方式</h1><h2 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h2><blockquote><p>​      即加密密钥和解密密钥相同的密钥体制，加密算法和解密算法公开，也是最常见的一种.对称加密算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p><p>​     常见对称加密算法：DES,3DES</p><p>​    对称加密的一大缺点是密钥的管理与分配，如何把密钥发送到需要解密的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人,如https的实现.</p></blockquote><h2 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h2><blockquote><p>加密密钥（公钥）和解密密钥（私钥）不同，且不能根据一个密钥得到另一个密钥。加密算法和解密算法公开.</p><p>非对称加密效率较低，但可以很方便的进行身份鉴别，数字签名。</p><p>常见对称加密算法：RSA,DSA </p><p><strong>公钥用来加密，验证签名；私钥用来解密，签名</strong>。</p><p>​       数字签名：CA机构以签名的形式对公开公钥的用户颁发一个数字证书的过程</p><p>​             特点：签名使得证书不能被修改</p><p>​                   <img src="/img/post_img/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p></blockquote><h2 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h2><h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><p>​       SSH的用户认证方式有两种，第一种是账户密码登录，即你需要连接的远程服务器某一个用户与密码，比较常用，也比较简单。第二种是公钥验证授权登录，适合批量化管理集群。</p><p>​         1. <strong>密码验证登录</strong></p><p>​             用户在客户端ssh远程服务器，远程服务器将自己的公用密钥下发至客户端的~/.ssh/known_hosts，客户端将使用该公开密钥来加密数据，远程服务器使用自己的私有密钥来解密数据，从而实现加密访问过程。</p><img src="/img/post_img/加密方式详解_ssh1.jpg" style="zoom:60%;"/><p>​         2.  <strong>免密登录</strong></p><p>​              本质：能实现免密登录是因为服务器端已经验证过客户端的合法身份，且将验证的记录保存在了本地。故无需再验证.  </p><p>​              具体流程： 客户端携带着公钥向服务器发出请求，服务器收到请求后，在 ~/.ssh/authorized_keys信任文件里比对该公钥是否存在，如果对比成功，远端服务器则使用该公钥加密一个随机字符串（challenge）发送给客户端。客户端接收后，将随机字符串（challenge）用自己的私钥进行解密，之后将解密后的结果传给服务器，服务器对比传来的字符串是否一致，一致则建立连接。</p><img src="/img/post_img/加密方式详解_ssh2.jpg" style="zoom:60%;" /><h3 id="https的实现"><a href="#https的实现" class="headerlink" title="https的实现"></a>https的实现</h3><p>​     HTTPS同时采用了对称加密算法，非对称加密算法，hash算法。 一般使用的加密与HASH算法如下：</p><p>​               非对称加密算法：RSA，DSA/DSS<br>​               对称加密算法：AES，RC4，3DES<br>​               HASH算法：MD5，SHA1，SHA256<br>     <img src="/img/post_img/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_https.png"></p><p>   1）浏览器将自己支持的一套加密规则发送给网站。<br>   2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。并告知浏览器所选取的算法.<br> 3）浏览器获得网站证书之后浏览器要做以下工作：<br>      a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>      b) 如果证书受信任，或用户接受了不受信的证书，浏览器用对称加密生成一个密钥，将所用的对称加密算法和生成的密钥用证书中提供的公钥加密。<br>      c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br> 4）网站接收浏览器发来的数据之后要做以下的操作：<br>      a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>      b) 使用密码加密一段握手消息，发送给浏览器。<br> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。<br>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p><p>证书示例：<br>    <img src="/img/post_img/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>SSH免密原理</tag>
      
      <tag>https原理</tag>
      
      <tag>对称/非对称</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus 代码生成</title>
    <link href="/2022/03/12/Mybatis-Plus%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
    <url>/2022/03/12/Mybatis-Plus%20%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis-Plus-代码生成"><a href="#Mybatis-Plus-代码生成" class="headerlink" title="Mybatis-Plus 代码生成"></a>Mybatis-Plus 代码生成</h1><h2 id="1-MP-Generator"><a href="#1-MP-Generator" class="headerlink" title="1.MP-Generator"></a>1.MP-Generator</h2><blockquote><p> 1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>2.进行生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">FastAutoGenerator.create(<span class="hljs-string">&quot;url&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>)<br>    .globalConfig(builder -&gt; &#123;<br>        builder.author(<span class="hljs-string">&quot;baomidou&quot;</span>) <span class="hljs-comment">// 设置作者</span><br>            .enableSwagger() <span class="hljs-comment">// 开启 swagger 模式</span><br>            .fileOverride() <span class="hljs-comment">// 覆盖已生成文件</span><br>            .outputDir(<span class="hljs-string">&quot;D://&quot;</span>); <span class="hljs-comment">// 指定输出目录</span><br>    &#125;)<br>    .packageConfig(builder -&gt; &#123;<br>        builder.parent(<span class="hljs-string">&quot;com.baomidou.mybatisplus.samples.generator&quot;</span>) <span class="hljs-comment">// 设置父包名</span><br>            .moduleName(<span class="hljs-string">&quot;system&quot;</span>) <span class="hljs-comment">// 设置父包模块名</span><br>            .pathInfo(Collections.singletonMap(OutputFile.mapperXml, <span class="hljs-string">&quot;D://&quot;</span>)); <span class="hljs-comment">// 设置mapperXml生成路径</span><br>    &#125;)<br>    .strategyConfig(builder -&gt; &#123;<br>        builder.addInclude(<span class="hljs-string">&quot;t_simple&quot;</span>) <span class="hljs-comment">// 设置需要生成的表名</span><br>            .addTablePrefix(<span class="hljs-string">&quot;t_&quot;</span>, <span class="hljs-string">&quot;c_&quot;</span>); <span class="hljs-comment">// 设置过滤表前缀</span><br>    &#125;)<br>    .templateEngine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FreemarkerTemplateEngine</span>()) <span class="hljs-comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span><br>    .execute();<br><br></code></pre></td></tr></table></figure></blockquote><h2 id="2-MybatisX-插件"><a href="#2-MybatisX-插件" class="headerlink" title="2.MybatisX 插件"></a>2.MybatisX 插件</h2><blockquote><p>1.在idea插件商店安装 MybatisX</p><p>2.连接数据库 选择表 右键 选择mybatisX代码生成 （“不会生成controller”）</p><p>3.复杂sql 查询编写 使用mybatisX代码提醒  会自动生成mapper.xml</p></blockquote><h2 id="3-其他代码生成插件"><a href="#3-其他代码生成插件" class="headerlink" title="3.其他代码生成插件"></a>3.其他代码生成插件</h2><blockquote><p>如 Easycode   MybatiisCodeHelperPro (paid)</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>代码生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/2022/03/08/Git%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/03/08/Git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>托管中心</strong><code>维护远程库</code></p><ul><li><strong>内网：可以自己搭建一个GitLab服务器</strong></li><li><strong>外网：可以使用码云、Github</strong></li></ul><p><strong>版本控制工具</strong></p><ul><li><strong>集中式</strong>：CSV ,<strong>SVN</strong>,VSS</li><li><strong>分布式</strong>：<strong>Git</strong>，Darcs,…</li></ul><h2 id="Git命令行操作"><a href="#Git命令行操作" class="headerlink" title="Git命令行操作"></a>Git命令行操作</h2><h3 id="1-1本地库初始化"><a href="#1-1本地库初始化" class="headerlink" title="1.1本地库初始化"></a>1.1本地库初始化</h3><p><code>进入文件夹</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br>注意：生成的 .git 目录中存放的是本地库相关文件，不要删除<br></code></pre></td></tr></table></figure><h3 id="1-2设置签名"><a href="#1-2设置签名" class="headerlink" title="1.2设置签名"></a>1.2设置签名</h3><ul><li><p>项目(仓库)级别<code>仅在当前本地库有效</code></p>  <figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">git config <span class="hljs-literal">user</span>.<span class="hljs-keyword">name</span> tom  <span class="hljs-comment">#设置用户名tom</span><br>git config <span class="hljs-literal">user</span>.email liu@qq.com <span class="hljs-comment">#设置用户邮箱</span><br></code></pre></td></tr></table></figure></li><li><p>系统用户级别<code>仅在当前登录的操作系统用户有效</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name tom</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email liu@qq.com</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>仅仅加了一个 <code>--global</code></p><p>优先级别：<code>项目级别</code>  &gt;  <code>系统级别</code></p><p>信息保存位置：<code>~/.gitconfig 文件</code>   </p></blockquote><h3 id="1-3基本操作"><a href="#1-3基本操作" class="headerlink" title="1.3基本操作"></a>1.3基本操作</h3><h4 id="1-3-1-状态查看"><a href="#1-3-1-状态查看" class="headerlink" title="1.3.1 状态查看"></a>1.3.1 状态查看</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> status   <span class="hljs-comment">#查看工作区、暂存区状态</span><br></code></pre></td></tr></table></figure><h4 id="1-3-2-添加"><a href="#1-3-2-添加" class="headerlink" title="1.3.2 添加"></a>1.3.2 添加</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> fileName  <span class="hljs-meta">#指定文件</span><br>git <span class="hljs-keyword">add</span> . <span class="hljs-meta">#所有</span><br>说明：将工作区的文件添加到暂存区<br></code></pre></td></tr></table></figure><h4 id="1-3-3-提交"><a href="#1-3-3-提交" class="headerlink" title="1.3.3 提交"></a>1.3.3 提交</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&#x27;commit message&#x27;</span> fileName<br>说明：将暂存区内容提交到本地库<br></code></pre></td></tr></table></figure><h4 id="1-3-4-查看历史记录"><a href="#1-3-4-查看历史记录" class="headerlink" title="1.3.4 查看历史记录"></a>1.3.4 查看历史记录</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span> <br>git reflog  <span class="hljs-meta">#常用</span><br>git <span class="hljs-built_in">log</span> --greph <span class="hljs-meta">#图形显示,更直观</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline <span class="hljs-meta">#漂亮一行显示</span><br>git <span class="hljs-built_in">log</span> --oneline <span class="hljs-meta">#简洁显示</span><br>说明：HEAD@&#123;移动到当前版本需要多少步&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-5-前进后退"><a href="#1-3-5-前进后退" class="headerlink" title="1.3.5 前进后退"></a>1.3.5 前进后退</h4><ul><li><p>基于索引值<code>推荐</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 指针位置</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard a6ace91 #回到这个状态</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <strong>^</strong> 符号<code>只能后退</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^^</span><br>注意：几个 ^ 表示后退几步<br></code></pre></td></tr></table></figure></li><li><p>使用 <strong>~</strong> 符号<code>只能后退</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~n</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~3</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-6-reset的三个参数比较"><a href="#1-3-6-reset的三个参数比较" class="headerlink" title="1.3.6 reset的三个参数比较"></a>1.3.6 reset的三个参数比较</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">soft</span><span class="hljs-punctuation">: </span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">仅本地库移动HEAD 指针</span><br><span class="hljs-attribute">mixed</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">在本地库移动HEAD指针</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置暂存区</span><br><span class="hljs-attribute">hard</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">在本地库移动HEAD指针</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置暂存区</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置工作区</span><br></code></pre></td></tr></table></figure><h4 id="1-3-7-删除文件并找回"><a href="#1-3-7-删除文件并找回" class="headerlink" title="1.3.7　删除文件并找回"></a>1.3.7　删除文件并找回</h4><ul><li><strong>相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回</strong></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 指针位置</span><br></code></pre></td></tr></table></figure><h4 id="1-3-8-文件差异比较"><a href="#1-3-8-文件差异比较" class="headerlink" title="1.3.8 文件差异比较"></a>1.3.8 文件差异比较</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">diff </span>文件名<br>git <span class="hljs-keyword">diff </span>哈希值 文件名  <span class="hljs-comment">#和历史中的一个版本比较</span><br>git <span class="hljs-keyword">diff </span> <span class="hljs-comment">#不带文件名，则比较多个文件</span><br></code></pre></td></tr></table></figure><h3 id="2-2-分支管理"><a href="#2-2-分支管理" class="headerlink" title="2.2 分支管理"></a>2.2 分支管理</h3><p><code>hot_fix</code> <code>master</code> <code>feature_x</code> <code>feature_y</code></p><h4 id="2-2-1-什么是分支管理"><a href="#2-2-1-什么是分支管理" class="headerlink" title="2.2.1 什么是分支管理"></a>2.2.1 什么是分支管理</h4><ul><li>在版本控制中，使用推进多个任务</li></ul><h4 id="2-2-2-分支的好处"><a href="#2-2-2-分支的好处" class="headerlink" title="2.2.2 分支的好处"></a>2.2.2 分支的好处</h4><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>某一分支开发失败，不会对其它分支有任何影响</li></ul><h4 id="2-2-3-分支操作"><a href="#2-2-3-分支操作" class="headerlink" title="2.2.3 分支操作"></a>2.2.3 分支操作</h4><ul><li>创建分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>分支名<br></code></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch</span><br><span class="hljs-keyword"></span>git <span class="hljs-keyword">branch </span>-v <br></code></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git checkout 分支名<br>git checkout -<span class="hljs-keyword">b </span>分支名   <span class="hljs-comment">#创建分支并直接切换到该分支</span><br></code></pre></td></tr></table></figure><ul><li>合并分支<code>相当于把修改了的文件拉过来</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git merge xxx<br>注意：合并分支的时候要明确谁谁合并<br>我在a分支里面修改了。要合并到<span class="hljs-literal">master</span>，就先切换到<span class="hljs-literal">master</span>，然后合并b<br></code></pre></td></tr></table></figure><ul><li>删除分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-d 分支名<br></code></pre></td></tr></table></figure><h4 id="2-2-4-解决冲突"><a href="#2-2-4-解决冲突" class="headerlink" title="2.2.4 解决冲突"></a>2.2.4 解决冲突</h4><ul><li>冲突的表现</li><li>冲突的解决<ul><li>第一步：编辑，删除特殊标记<code>&lt;&lt;&lt;</code> <code>===</code></li><li>第二步：修改到满意位置，保存退出</li><li>第三步：添加到缓存区  <code>git  add 文件名</code></li><li>第四步：提交到本地库<code>git commit -m &#39;日志信息&#39; </code>  <code>注意：后面一定不能带文件名</code></li></ul></li></ul><h2 id="Git-结合Github"><a href="#Git-结合Github" class="headerlink" title="Git 结合Github"></a>Git 结合Github</h2><p><code>别分手</code>  <code>别名 分支名</code></p><h4 id="1-1-创建远程库地址别名"><a href="#1-1-创建远程库地址别名" class="headerlink" title="1.1 创建远程库地址别名"></a>1.1 创建远程库地址别名</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git remote -v  <span class="hljs-meta">#查看 （远程主机名）</span><br>git remote <span class="hljs-keyword">add</span> 远程主机名 远程地址 <br>例子：git remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//xx</span><br></code></pre></td></tr></table></figure><h4 id="1-2-推送"><a href="#1-2-推送" class="headerlink" title="1.2 推送"></a>1.2 推送</h4><p><code>开发修改完把本地库的文件推送到远程仓库</code> <code>前提是提交到了本地库才可以推送</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span> 别名 分支名<br>git <span class="hljs-keyword">push</span> -u 别名 分支名    <span class="hljs-meta">#-u指定默认主机</span><br>例子：git <span class="hljs-keyword">push</span> origin master <br></code></pre></td></tr></table></figure><h4 id="1-3-克隆"><a href="#1-3-克隆" class="headerlink" title="1.3 克隆"></a>1.3 克隆</h4><p><code>完整的把远程库克隆到本地</code>  <code>克隆下来后不要在主分支里面做开发</code> <code>clone进行一次，从无到有的过程，更新用pull</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span>  <span class="hljs-title">远程地址</span><br><span class="hljs-title">例子：git</span> <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://xx<br></code></pre></td></tr></table></figure><h4 id="1-4-拉取"><a href="#1-4-拉取" class="headerlink" title="1.4 拉取"></a>1.4 拉取</h4><p>  <code>本地存在clone下来的文件  就用pull更新</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">pull <span class="hljs-operator">=</span> <span class="hljs-keyword">fetch</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">merge</span><br>git <span class="hljs-keyword">fetch</span> 别名 分支名<br>git <span class="hljs-keyword">merge</span> 别名 分支名<br>git pull 别名 分支名<br></code></pre></td></tr></table></figure><h4 id="1-5-解决冲突"><a href="#1-5-解决冲突" class="headerlink" title="1.5 解决冲突"></a>1.5 解决冲突</h4><p><code>注意：解决冲突后的提交是不能带文件名的</code></p><p><code>如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决</code></p><h4 id="1-6-rebase"><a href="#1-6-rebase" class="headerlink" title="1.6 rebase"></a>1.6 rebase</h4><p><code>提交记录简洁不分叉</code>  <code>没学懂，感觉有点鸡肋</code> <code>混眼熟</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">git rebase -<span class="hljs-selector-tag">i</span> 索引号<br>git rebase -<span class="hljs-selector-tag">i</span> HEAD~<span class="hljs-number">3</span>  #合并最近三条记录<br>说明：在vim编辑里面改成s<br></code></pre></td></tr></table></figure><h4 id="1-7-beyond-compare"><a href="#1-7-beyond-compare" class="headerlink" title="1.7 beyond compare"></a>1.7 beyond compare</h4><p><code>用软件解决冲突</code> </p> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-number">1.</span>安装 ：<br>beyond compare <br><span class="hljs-number">2.</span>配置：<br>    git config --<span class="hljs-keyword">local</span> merge.tool bc3  <span class="hljs-meta">#合并名称</span><br>    git config --<span class="hljs-keyword">local</span> mergetool.path <span class="hljs-string">&#x27;/usr/local/bin/bcomp&#x27;</span> <span class="hljs-meta">#软件路径</span><br>    git config --<span class="hljs-keyword">local</span> mergetool.keepBackup <span class="hljs-literal">false</span>  <span class="hljs-meta">#False不用保存备份</span><br><span class="hljs-number">3.</span>应用：<br>git mergetool<br>说明：--<span class="hljs-keyword">local</span>指只在当前操作系统有效<br></code></pre></td></tr></table></figure><h4 id="1-8-跨团队合作"><a href="#1-8-跨团队合作" class="headerlink" title="1.8 跨团队合作"></a>1.8 跨团队合作</h4><p><code>代码review之后合并</code></p><ul><li><p><strong>适用于个人</strong></p><p><strong>邀请成员</strong>:<code>Settings</code> –&gt; <code>Collaborators</code> –&gt;<code>填写用户名</code> –&gt;<code>打开链接接受邀请</code></p></li><li><p><strong>企业</strong>   <code>创建一个组织</code> <code>方便管理</code></p></li><li><p><strong>review</strong></p><p>  <code>组织做review</code>  <code>通过Pull request</code></p></li><li><p><strong>给开源社区共享代码</strong></p><p>  <code>点击别人仓库的fork 到自己的仓库</code>   – &gt; <code>然后clone下来 修改后推送到远程库</code>  –&gt; <code>点击Pull Request请求</code> –&gt; <code>Create pull request发消息</code></p></li></ul><h4 id="1-9-Tag标签"><a href="#1-9-Tag标签" class="headerlink" title="1.9 Tag标签"></a>1.9 Tag标签</h4><p><code>为了清晰的版本管理，公司一般不会直接使用commit提交</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">0</span> -m &#x27;版本介绍&#x27;   <span class="hljs-comment">#创建本地tag信息</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">0</span>    <span class="hljs-comment">#删除tag</span><br>git push origin --tags   <span class="hljs-comment">#将本地tag信息推送到远程库</span><br>git pull origin --tags    <span class="hljs-comment">#拉取到本地</span><br><br>git checkout v.<span class="hljs-number">10</span>    <span class="hljs-comment">#切换tag</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> v0.<span class="hljs-number">1</span> 地址   <span class="hljs-comment">#指定tag下载代码</span><br></code></pre></td></tr></table></figure><h4 id="1-10-SSH-免密登录"><a href="#1-10-SSH-免密登录" class="headerlink" title="1.10 SSH 免密登录"></a>1.10 SSH 免密登录</h4><ul><li>输入:<code>ssh-keygen -t rsa -C GitHub邮箱地址</code>  </li><li>进入<code>.ssh</code>目录，复制<code>id_rsa.pub</code>文件内容</li><li>登录GitHub。<code>Settings</code>  –&gt; <code>SSH and GPG keys </code> –&gt; <code>New SSH Key    </code></li><li>回到git通过ssh地址创建。<code>git remote add 别名 SSH地址  </code></li></ul><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在项目开发过程中使用Git的方式<br></code></pre></td></tr></table></figure><h4 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h4><h5 id="1-2-1-集中式工作流"><a href="#1-2-1-集中式工作流" class="headerlink" title="1.2.1 集中式工作流"></a>1.2.1 集中式工作流</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了<span class="hljs-literal">Master</span>分支上<br></code></pre></td></tr></table></figure><h5 id="1-2-2-GitFlow工作流"><a href="#1-2-2-GitFlow工作流" class="headerlink" title="1.2.2 GitFlow工作流 *"></a>1.2.2 GitFlow工作流 <code>*</code></h5><p>主干分支<code>master</code>  开发分支<code>develop</code>  修复分支<code>hotfix</code>   预发布分支<code>release</code>  功能分支<code>feature</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">GitFlow</span> 有独立的分支，让发布迭代过程更流畅。<br></code></pre></td></tr></table></figure><h5 id="1-2-3-Forking-工作流"><a href="#1-2-3-Forking-工作流" class="headerlink" title="1.2.3 Forking 工作流"></a>1.2.3 Forking 工作流</h5><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull <span class="hljs-built_in">request</span> 的功能以达到代码审核的目的。 <br>安全可靠地管理大团队的开发者<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DesignPriciple</title>
    <link href="/2022/02/18/DesignPriciple/"/>
    <url>/2022/02/18/DesignPriciple/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式7大原则（Java-版）"><a href="#设计模式7大原则（Java-版）" class="headerlink" title="设计模式7大原则（Java 版）"></a><strong>设计模式7大原则（Java 版）</strong></h1><h2 id="面向对象设计原则概述"><a href="#面向对象设计原则概述" class="headerlink" title="面向对象设计原则概述"></a>面向对象设计原则概述</h2><p><strong>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一</strong></p><p><strong>各大设计原则不是独立存在的，存在相互依赖，相互补充的关系，甚至有些原则只是某个原则的延伸，具体实现等.</strong></p><p><strong>使用设计模式的目的就是 尽可能低代价的实现代码功能的复用与扩充，提高代码的可维护性 ；达到高内聚低耦合</strong></p><h2 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则 (SRP)"></a>1.单一职责原则 (SRP)</h2><p>​    <strong>Single Responsibility Principle</strong></p><h3 id="单一职责定义"><a href="#单一职责定义" class="headerlink" title="单一职责定义"></a>单一职责定义</h3><blockquote><p>一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因</p></blockquote><h3 id="单一职责实例"><a href="#单一职责实例" class="headerlink" title="单一职责实例"></a>单一职责实例</h3><p>​      有如下类登录、注册、支付宝押金支付、微信押金支付、套餐支付、整个结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户功能模块</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userController</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 押金支付(阿里)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payAliDeposit</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 押金支付(微信)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payWXDeposit</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 套餐支付</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payPackage</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​        如上很多功能都糅杂在一起，一个类做了很多事情，很臃肿，各个方法间无紧密联系. 所以我们可以对这个UserController进行拆解，与此同时我们应该分包，比如这个应该在xxx.xxx.userMoudule下面，可能支付相关的有公共的方法，登录抑或也有公共的方法，那边抽取成公共服务去调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span>()&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">registerController</span>()&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">depositPayController</span>()&#123;<br>    <span class="hljs-comment">// 支付宝支付</span><br>    <span class="hljs-comment">// 微信支付</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">packagePayController</span>()&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2.开闭原则 (OCP)"></a>2.开闭原则 (OCP)</h2><p>​    <strong>Open Close Principle</strong></p><h3 id="开闭原则定义"><a href="#开闭原则定义" class="headerlink" title="开闭原则定义"></a>开闭原则定义</h3><blockquote><p>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>  软件实体包括</p><ul><li><p>项目中的模块</p></li><li><p>抽象和类</p></li><li><p>方法  </p><p><strong>使用开闭原则的好处</strong>：不影响原代码的运行，提高了可维护性，复用性</p></li></ul><p><strong>开闭原则使用方式</strong></p><p>​    <strong>抽象约束</strong></p><ul><li><p>通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；</p></li><li><p>参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；（针对抽象编程）</p></li><li><p>抽象层尽量保持稳定，一旦确定即不允许修改。</p></li></ul><p>​    <strong>元数据控制模块行为</strong><br>​      通过配置文件来操作数据，spring的控制反转(application.xml控制对象的创建)就是一个很典型的例子。<br>​      依赖注入是实现开闭原则的一种方式.</p><p>   <strong>约定优于配置</strong></p><p>   <strong>封装变化</strong></p><p>   <strong>将相同的变化封装到一个接口或者类中</strong></p><p>   <strong>将不同的变化封装到不同的类或者接口中（单一职责的体现）</strong></p><h3 id="开闭原则实例"><a href="#开闭原则实例" class="headerlink" title="开闭原则实例"></a>开闭原则实例</h3><p>  某租车系统有一个押金支付功能，支付方式有支付宝、阿里支付，后期可能还有银联支付、易支付等等，设计方案如下：</p><p><img src="/img/post_img/DesignPriciple_1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端调用-押金支付选择支付手段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepositPay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String type)</span>&#123;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;ali&quot;</span>))&#123;<br>            <span class="hljs-type">AliPay</span> <span class="hljs-variable">aliPay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliPay</span>();<br>            aliPay.pay();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;wx&quot;</span>))&#123;<br>            <span class="hljs-type">WXPay</span> <span class="hljs-variable">wxPay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WXPay</span>();<br>            wxPay.pay();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 支付宝支付</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支付宝支付&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 微信支付</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WXPay</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;微信支付&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，如果需要增加银联支付，如YLPay,那么就必须要修改DepositPay中的pay方法的源代码，增加新的判断逻辑，违反了开闭原则（对修改关闭，对扩展开放），所以现在必须重构此代码，让其遵循开闭原则，做法如下：</p><p>增加一个接口，使得各种具体支付实现其接口DepositPay类针对接口编程，由客户端来决定具体使用哪种支付方式<br><img src="/img/post_img/DesignPriciple_2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span> &#123;<br>     .....<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WXPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span>&#123;<br>     .....<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CardPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在使用微信支付&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端调用-押金支付选择支付手段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepositPay</span> &#123;<br>    <span class="hljs-comment">//paymode写在配置文件可以直接编辑，且不需要编译，所以一般不认为更改配置文件是更改源码。</span><br>    <span class="hljs-comment">//如果一个系统能做到只需要修改配置文件，无需修改源码，那么复合开闭原则</span><br>    <span class="hljs-meta">@Autowired</span><br>    Pay payMode;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Pay payMode)</span>&#123;<br>        payMode.pay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-里式替换原则-LSP"><a href="#3-里式替换原则-LSP" class="headerlink" title="3.里式替换原则 ( LSP )"></a>3.里式替换原则 ( LSP )</h2><p>​    <strong>Liskov Substitution Principle</strong></p><h3 id="里氏替换原则定义"><a href="#里氏替换原则定义" class="headerlink" title="里氏替换原则定义"></a>里氏替换原则定义</h3><blockquote><p>定义一： 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p><p>  第二定义：<strong>子类能够透明地替代父类的功能</strong>        </p></blockquote><p>​        子类可以透明替换父类  =&gt;  表明基类可以复用<br>​        父类无法等价替换子类  =&gt;  子类对父类的功能做了修改，实现，扩充  </p><p>​       实现开闭原则的关键步骤就是抽象化，而子类对基类的可以透明替换就是抽象化（实现复用）的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p><h3 id="里氏替换原则实例"><a href="#里氏替换原则实例" class="headerlink" title="里氏替换原则实例"></a><strong>里氏替换原则实例</strong></h3><p>​      java中的实例：Collection接口和其实现类的关系，</p><p>​      某租车系统客户分为普通用户和VIP客户，系统需要提供一个根据邮箱重置密码的功能。原始设计图：</p><p><img src="/img/post_img/DesignPriciple_3.png"></p><p>​     在编写重置密码的时候发现，业务逻辑是一样的，存在着大量的重复代码，而且还可能增加新的用户类型，为了减少代码重复性，使用里氏替换原则进行重构</p><p><img src="/img/post_img/DesignPriciple_4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonCustomer</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Customer</span>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VIPCustomer</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Customer</span>&#123;<br>&#125;<br><span class="hljs-comment">// 重置密码逻辑在这里实现，只需要传入对应的类型即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetPassword</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetPassword</span><span class="hljs-params">(Customer customer)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>里氏替换原则是实现开闭原则不可或缺的手段之一</code>，<strong>在本例中，通过传递参数使用基类对象，针对抽象编程，从而满足开闭原则。</strong></p><h2 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则  (DIP)"></a>4.依赖倒置原则  (DIP)</h2><p>​    <strong>Dependence Inversion Principle</strong></p><h3 id="依赖倒转原则定义"><a href="#依赖倒转原则定义" class="headerlink" title="依赖倒转原则定义"></a>依赖倒转原则定义</h3><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。即面向接口编程</p></blockquote><p>​     在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</p><p> 常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入<br><strong>依赖倒转原则实例</strong>：</p><p>​      如OCP原则中的实例各种支付方式依赖pay接口，java中collection接口和实现类</p><h2 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则 (ISP)"></a>5.接口隔离原则 (ISP)</h2><p>​    <strong>Interface Segregation Principle</strong></p><h3 id="接口隔离原则定义"><a href="#接口隔离原则定义" class="headerlink" title="接口隔离原则定义"></a>接口隔离原则定义</h3><blockquote><ol><li>使用多个专门的接口，而不使用单一的总接口，即不应该依赖那些它不需要的接口（最小接口）</li><li>类间的依赖关系应该建立在最小的接口上 </li></ol></blockquote><p>​     一个类实现一个接口时，这个接口中应该只有该类用到的抽象方法，否则就会造成该类仍需实现它所以用不到的方法，造成了接口污染。</p><h3 id="接口隔离原则实例"><a href="#接口隔离原则实例" class="headerlink" title="接口隔离原则实例"></a>接口隔离原则实例</h3><p>接口IAnimal有两个实现类，Bird和Tony,但明显IAnimal中某些方法子类用不到，一次要对接口进行重构</p><p><img src="/img/post_img/DesignPriciple_5.png"></p><p>  接口重构：将接口拆分若干个子接口，按需继承</p><p>​     <img src="/img/post_img/DesignPriciple_6.png"></p><h2 id="6-合成复用原则-CRP"><a href="#6-合成复用原则-CRP" class="headerlink" title="6.合成复用原则 (CRP)"></a>6.合成复用原则 (CRP)</h2><p>​    <strong>Composite Reuse Principle</strong></p><h3 id="合成复用原则定义"><a href="#合成复用原则定义" class="headerlink" title="合成复用原则定义"></a>合成复用原则定义</h3><blockquote><p>通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p></blockquote><p> 在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><p>复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分（属性），新对象可以调用已有对象的功能，它有以下优点。</p><ol><li><p>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</p></li><li><p>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</p></li><li><p>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p><p><strong>合成复用原则实现方式</strong>：构造器注入，属性注入，方法传参   即如spring中依赖注入方式</p></li></ol><h3 id="合成复用原则实例"><a href="#合成复用原则实例" class="headerlink" title="合成复用原则实例"></a>合成复用原则实例</h3><p><img src="/img/post_img/DesignPriciple_7.gif"></p><p>   用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p><p><img src="/img/post_img/DesignPriciple_8.gif"></p><p>​       Color以属性的形式聚合在类Car中</p><h2 id="7-迪米特法则-最少知道原则-LoD-LKP"><a href="#7-迪米特法则-最少知道原则-LoD-LKP" class="headerlink" title="7.迪米特法则/最少知道原则 (LoD  /LKP)"></a>7.迪米特法则/最少知道原则 (LoD  /LKP)</h2><p>​    <strong>Law of Demeter / Least Knowledge Principle</strong></p><h3 id="迪米特法则定义"><a href="#迪米特法则定义" class="headerlink" title="迪米特法则定义"></a>迪米特法则定义</h3><blockquote><p>一个对象应该对其他对象有最少的理解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被调用或耦合的类）的内部是如何地复杂与我无关，那是你的事情，我就知道你提供了这么多的public方法，我就调用这么多，其他我一概不关心。</p></blockquote><p> 特点：</p><ul><li>只和朋友交流</li></ul><p>​      朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。</p><p> 即不要让陌生类出现在方法中，使用中介的形式与形式与陌生类交流</p><h3 id="迪米特法则实例"><a href="#迪米特法则实例" class="headerlink" title="迪米特法则实例"></a>迪米特法则实例</h3><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="http://www.itcast.cn/files/image/202108/20210819160555909.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//明星</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//粉丝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fans</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//公司</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//经济人</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span> &#123;<br>    <span class="hljs-comment">//聚合其他类作为属性</span><br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStar</span><span class="hljs-params">(Star star)</span> &#123;<br>        <span class="hljs-built_in">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFans</span><span class="hljs-params">(Fans fans)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(Company company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meeting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​     <strong>SOLID</strong>: 意为 可靠的   是指面向对象的5大设计原则（共有7大原则省略了迪米特和合成复用原则）</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
