<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日期类</title>
    <link href="/2022/10/16/%E6%97%A5%E6%9C%9F%E7%B1%BB/"/>
    <url>/2022/10/16/%E6%97%A5%E6%9C%9F%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h2><p>​    大部分功能已被剔除，但更具通用性，sql包下也有date类,但推荐使用util下的</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo1</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//日期</span><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();   <span class="hljs-comment">//如Thu Oct 20 17:56:17 CST 2022</span><br>        System.out.println(date); <span class="hljs-comment">//格式：星期四 十月20日  时间  时区  年份</span><br><br>        <span class="hljs-comment">//当前毫秒数      以1970年为基准</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">millis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(millis);<br><br>       <span class="hljs-comment">//格式转换   HH--&gt;24小时制  Z时区</span><br>        SimpleDateFormat dateFormat=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy--MM--dd hh:mm:ss  G  Z&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> dateFormat.format(date);<br>        System.out.println(time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h2><p> 不支持格式化， 使用起来较麻烦，有很多功能方法，不推荐用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//日历类  返回的类型类似一个set 里面包含当前毫秒，年，月，日，分，秒，时区等</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        System.out.println(calendar);<br><br>        <span class="hljs-comment">// 没有格式化工具  较麻烦 使用不多</span><br>        System.out.println(calendar.get(Calendar.YEAR)+<span class="hljs-string">&quot;-&quot;</span>+calendar.get(Calendar.MONTH));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h2><p> jdk1.8才支持 ，通用性不好 （mysql5.7及以下可能不支持该类型）</p><table><thead><tr><th align="center">类型</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">LocalTime</td><td align="center">时间</td></tr><tr><td align="center">LocalDateTime</td><td align="center">日期时间</td></tr><tr><td align="center">Instant</td><td align="center">时间戳</td></tr><tr><td align="center">LocalDate</td><td align="center">日期</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">demo3</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now();<br>        System.out.println(date);<br><br>        <span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();<br>        System.out.println(time);<br><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">dateTime</span> <span class="hljs-operator">=</span> LocalDate.now();<br>        System.out.println(dateTime);<br><br>        <span class="hljs-comment">//时间戳</span><br>        <span class="hljs-type">Instant</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> Instant.now();<br>        System.out.println(<span class="hljs-string">&quot;时间戳: &quot;</span>+now);<br>        System.out.println(<span class="hljs-string">&quot;时间戳转date:&quot;</span>+ Date.from(now));<br><br>        <span class="hljs-comment">//  格式化(三种均支持)</span><br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">timeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> timeFormatter.format(dateTime);<br>        System.out.println(s);<br>        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">timeFormatter1</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd &quot;</span>);<br>        System.out.println(timeFormatter1.format(date));<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>综上  推荐使用第一代，第三代次之。</strong></p><h2 id="mysql中的日期"><a href="#mysql中的日期" class="headerlink" title="mysql中的日期"></a>mysql中的日期</h2><p>使用datetime,不要使用时间戳，</p><table><thead><tr><th align="center">类型</th><th align="center">描述及示例</th></tr></thead><tbody><tr><td align="center">time</td><td align="center">表示时间  09:34:21</td></tr><tr><td align="center">date</td><td align="center">表示日期 2022-10-05</td></tr><tr><td align="center">timestamp</td><td align="center">时间戳（受时区，范围限制）2022-10-05 09:30:27</td></tr><tr><td align="center">datetime</td><td align="center">日期+时间  2022-10-05 09:30:27</td></tr><tr><td align="center">year</td><td align="center">年份1907</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>Datetime</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Web</title>
    <link href="/2022/07/28/JavaWeb/"/>
    <url>/2022/07/28/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="web相关概念"><a href="#web相关概念" class="headerlink" title="web相关概念"></a>web相关概念</h2><figure class="highlight markdown"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs markdown">web（World Wide Web）即全球广域网。它是一种基于HTTP的、全球性的、动态交互的、跨平台的分布式信息系统。<br><br>Web 应用程序：可以提供给浏览器访问的程序。网页是web应用程序最重要的元素。 <br> 一个JavaWeb应用程序由多部分组成：<br><span class="hljs-bullet">  -</span> html，css，js<br><span class="hljs-bullet">  -</span> jsp，servlet<br><span class="hljs-bullet">  -</span> java程序<br><span class="hljs-bullet">  -</span> 配置文件<br>  <br>资源分类<br><span class="hljs-bullet">1.</span> 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析<br><span class="hljs-bullet">*</span> 如： html,css,JavaScript<br><span class="hljs-bullet">2.</span> 动态资源:每个用户访问，得到的结果可能不一样，称为动态资源。动态资源需要先转换为静态资源，再返回给浏览器<br><span class="hljs-bullet">*</span> 如：servlet/jsp,php,asp....<br>  <br> Web服务器即存放Web应用程序的服务器（故又被称为web容器）<br>   职责：接收用户的请求，处理请求，做出响应。<br>   常见服务器：Netty,Tomcat,JBoss,Apache等。<br></code></pre></td></tr></table></figure><h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><p>​       HTTP是一个请求-响应协议，运行于TCP层上，属于应用层协议。web中的资源是基于http协议在网络中传输的 ，是web都必须遵守的标准。</p><p> 特点：无连接 （每次请求得到响应即断开链接 ,指http1.0），无状态（每一对请求响应之间独立，不共享信息）</p><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">http1<span class="hljs-number">.0</span> :短链接<br>   浏览器和服务器每进行一次HTTP操作，就建立一次TCP连接，任务结束就中断连接。<br><br>http1<span class="hljs-number">.1</span> :长链接（客户端和服务器的HTTP头部的<span class="hljs-keyword">Connection</span>设置为keep-alive）<br>   多个HTTP请求可以复用同一个TCP连接，节省了TCP连接建立和断开的消耗。<br><br>http2<span class="hljs-number">.0</span> : 更安全，高效<br>   基于https(采用SSL加密)<br>   压缩头部（<span class="hljs-keyword">Header</span>）：多个请求，若<span class="hljs-keyword">header</span>是一样的,协议会帮你消除重复的部分。<br>   二进制格式：HTTP1<span class="hljs-number">.1</span>的解析是基于文本。HTTP2<span class="hljs-number">.0</span>的协议解析采用二进制格式，头信息和数据体都是二进制。<br>  <br></code></pre></td></tr></table></figure><h3 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs txt">http请求格式<br>   请求行： 请求方法  url   协议版本<br>   请求头： 若干个键值对组成（请求头属性 : 请求头属性值） <br>   请求空行： 一个空行（格式控制）<br>   请求体： 具体的请求数据（非必须，如get方式没有）<br>eg:<br>POST https://www.csdn.net/community/ HTTP/1.1   //此处为请求行<br>Host: www.csdn.net<br>Accept: application/json, text/javascript, */*; q=0.01<br>Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br>Connection: keep-alive<br>Cookie: uuid_tt_dd=10_18653979800-1652881261106-378096; <br>                                               //此处为请求空行<br>username=tom&amp;password=123                      //此处为请求体<br><br><br><br>http响应格式<br>    状态行： 协议版本  状态码 状态码解释<br>    响应头： 若干个 响应头属性 : 响应头属性值<br>    响应空行：一个空行（格式控制）<br>    响应体： 具体的响应数据<br>eg: <br>HTTP/1.1 200 OK                                //此处为状态行<br>Server: openresty<br>Date: Thu, 19 May 2022 10:27:12 GMT<br>Vary: Origin<br>Vary: Access-Control-Request-Method<br>                                            //此处为 响应空行                                    <br>&#123;&quot;code&quot;:200,&quot;msg&quot;:&quot;success&quot;,&quot;data&quot;:         //此处及后面响应体 <br>    &#123;&quot;nickName&quot;:&quot;IT自习小空ssssssss   间&quot;,&quot;avatar&quot;:&quot;https://profile.csdnimg.cn/f/7/2/3_jiangnb520&quot;,&quot;fansCount&quot;:79,&quot;likeCount&quot;:31,&quot;vip&quot;:2,&quot;followCount&quot;:35&#125;&#125; <br></code></pre></td></tr></table></figure><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>  有多种请求方式，此处仅列举几种。</p><p>  Restful: 称之为REST风格（表述性状态传递）。  简单来说网络上的资源由唯一的url标识，通过请求方式不同来<strong>隐藏对资源的访问行为</strong>（非restful直接通过url来表现对资源的访问行为），使得url更简短。</p><p>   /get  查询  ，/post  更新 ， /put  创建 ,  /delete  删除。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">GET<br>向特定的资源发出查询请求。<br><br>POST<br>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br><br>PUT<br>向指定资源位置上传其最新内容<br><br>DELETE<br>请求服务器删除Request-URL所标识的资源<br></code></pre></td></tr></table></figure><h2 id="会话技术-域"><a href="#会话技术-域" class="headerlink" title="会话技术  /  域"></a>会话技术  /  域</h2><p>​      会话： 即浏览器和一个网站的所有请求响应的全过程称之为一次会话。</p><p>​      作用：存储浏览器与服务器在请求和响应过程中产生的数据，解决数据共享问题    </p><h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h3><p>  客户端会话技术：在一次会话的多次请求之间共享数据，将数据保存到客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetCookieServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>　  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse　response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;  <span class="hljs-comment">//创建cookie（还可以设置其lifecycle）</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);<br>        response.addCookie(cookie);<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetCookieServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//读取cookie</span><br>        <span class="hljs-keyword">if</span>(cookies !=<span class="hljs-literal">null</span> )&#123;<br>            <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cookie.getName();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> cookie.getValue();<br>                System.out.println(name + <span class="hljs-string">&quot;----&quot;</span> + value );<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h3><p>​      服务端会话技术：在一次会话的多次请求之间共享数据，将数据保存到服务器端</p><p>​       Session是基于cookie实现的 ; </p><p>​       Session是一个域对象,存储于服务器；</p><p>​       Session作用范围：一次会话中经过的所有servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetSession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">// JSessionID的共享</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>        session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;哈哈,呵呵&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetSession</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Token"><a href="#Token" class="headerlink" title="Token:"></a>Token:</h3><p>   验证令牌，和session都可以用来验证身份</p><p>​    相比session的优点：无需占服务器大量内存，以及分布式场景下的session保存问题。</p><p>Token原理</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">用户携带 userID passWd登录<br>验证成功 生成用户唯一标识符(比如uuid)，并参用hash算法加密唯一标识符。形成<span class="hljs-built_in">token</span>&#123;UUID,hashCode&#125;<br>返回<span class="hljs-built_in">token</span>给客户端<br>客户端携带<span class="hljs-built_in">token</span>再次访问<br>服务器争对 uuid取hash 验证携带的hashCode与携带的是否一致<br></code></pre></td></tr></table></figure><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope:"></a>Scope:</h3><p> 域：由于http是无状态的，每对请求与响应之间独立，无法共享数据。所以通过设置域来实现共享数据。</p><p> 四大域：</p><table><thead><tr><th align="center">作用域对象</th><th>生命周期</th><th align="center">作用范围</th></tr></thead><tbody><tr><td align="center">request</td><td>用户发起的一次请求</td><td align="center">一次请求经过的servlet</td></tr><tr><td align="center">session</td><td>浏览器与服务器的一次会话</td><td align="center">会话中经过的所有servlet</td></tr><tr><td align="center">pageContext</td><td>jsp被创建</td><td align="center">当前JSP页面</td></tr><tr><td align="center">servletContext</td><td>从服务器启动到服务器关闭</td><td align="center">所有servlet都可以访问</td></tr></tbody></table><p> 请求域： 一个请求会创建一个request对象，若一个请求中经历了多个Servlet，则多个Servlet就可以使用request来共享数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请求域设置 request</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(String var1, Object var2)</span>;<br>Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(String var1)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">removeAttribute</span><span class="hljs-params">(String var1)</span>;<br><br><span class="hljs-comment">//请求重定向： 是浏览器行为 算两次请求  地址栏变化，不共享request域</span><br>response.sendRedirect(<span class="hljs-string">&quot;http://localhost:8080/Servlet1&quot;</span>)<br><span class="hljs-comment">//请求转发：   是服务器行为 算一次请求  地址栏不变化，共享request域</span><br>request.getRequestDispatcher(<span class="hljs-string">&quot;/anotherServlet&quot;</span>).forward(request, response);<br></code></pre></td></tr></table></figure><h2 id="Servlet-JSP"><a href="#Servlet-JSP" class="headerlink" title="Servlet / JSP"></a>Servlet / JSP</h2><p>​    Servlet : 即 Server Applet  (服务器小程序)  ，用来处理服务器接收到的请求的程序。服务器自身只能处理静态的资源请求，当服务器收到动态资源请求后，须由servlet处理后形成静态资源，响应给请求。</p><p>​     HttpServlet 即Web服务器端的小程序，由java官方基于http协议封装的一个Servlet。</p><h3 id="HttpServlet的运行流程"><a href="#HttpServlet的运行流程" class="headerlink" title="HttpServlet的运行流程"></a>HttpServlet的运行流程</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">浏览器发送一个 servlet 请求<br>服务器解析请求判断为Servlet请求 <br>服务器中生成请求对象(HttpServletRequest)和响应对象(HttpServletResponce)<br>服务器根据url找到目标ServletA,为其创建一个线程A<br>服务器将刚才创建的请求对象和响应对象传递给线程A<br>服务器创建servlet对象，然后调用该对象的service方法。<br>容器通过response获取处理结果，然后打包（响应数据包）发送给浏览器。<br>浏览器解析响应数据包，生成响应的页面<br></code></pre></td></tr></table></figure><h3 id="servlet配置"><a href="#servlet配置" class="headerlink" title="servlet配置"></a>servlet配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">基于配置文件<br>在JavaWeb项目的标准结构下<br>- java目录 （servlet和java代码）<br>- resource目录<br>- webapp目录 （web配置及jsp，html页面）<br>在webapp/WEB-INF目录下的web.xml中配置servlet信息<br>eg: <br>&lt;servlet&gt;<br>    &lt;servlet-name&gt;index&lt;/servlet-name&gt;<br>    &lt;servlet-class&gt;cookie.GetCookieServlet&lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br>&lt;servlet-mapping&gt;<br>    &lt;servlet-name&gt;index&lt;/servlet-name&gt;<br>    &lt;url-pattern&gt;/home&lt;/url-pattern&gt;<br>&lt;/servlet-mapping&gt;<br>        <br>基于注解<br><span class="hljs-meta">@WebServlet(name = &quot;index&quot;, value = &quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetCookieServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>​     Java Servlet Page  一个支持写java代码的页面.本质上还是一个Servlet.</p><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">指令标识: 设定整个JSP页面的相关信息，被服务器解释并执行的，不产生任何输出到网页中的内容（通常声明于页面顶部）<br>&lt;*%@ 指令类型 属性<span class="hljs-number">1</span>=“属性值<span class="hljs-number">1</span>” 属性<span class="hljs-number">2</span>=“属性值<span class="hljs-number">2</span>”%&gt;<br>eg: &lt;%@ include file=<span class="hljs-string">&quot;path&quot;</span>%&gt;     <span class="hljs-comment">//include指令用于引入公共页面</span><br>    &lt;%@ page  errorPage=<span class="hljs-string">&quot;./404.jsp&quot;</span> session=<span class="hljs-string">&quot;true&quot;</span>...%&gt;  <span class="hljs-comment">//page指令 设置页面java相关属性</span><br>    &lt;%@ taglib prefix=<span class="hljs-string">&quot;tagPrefix&quot;</span> uri=<span class="hljs-string">&quot;tagURI&quot;</span>%&gt;   <span class="hljs-comment">//标签库指令</span><br><br>脚本标识：书写java代码的地方 表达式的运行结果会以字符串形式输出在页面上<br>&lt;% = 表达式%&gt;<br>&lt;%! 声明变量或方法的代码 %&gt;<br>eg:<br>&lt;%!<br>    <span class="hljs-type">String</span> <span class="hljs-variable">tip</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;add()的结果是: &quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>%&gt;<br><span class="hljs-comment">//表达式输出只能有一条</span><br>&lt;%=<br>tip + add(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>)<br>%&gt;<br>&lt;img src=<span class="hljs-string">&quot;images/&lt;%url %&gt;&quot;</span>&gt; <span class="hljs-comment">//html页面也可以调用jsp声明的变量</span><br><br>&lt;%-- 注释内容 --%&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka基础</title>
    <link href="/2022/06/11/Kafka%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/06/11/Kafka%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka基础"><a href="#Kafka基础" class="headerlink" title="Kafka基础"></a>Kafka基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Kafka是一个分布式的消息发布订阅系统</p><p>Kafka   Broker 端使用 Zookeeper 注册 broker 信息后，选取一个leader broker 监控 Partition leader 存活性；Kafka Producer 端直接连接 broker.list 列表。Comsumer 端则使用 Zookeeper 注册 comsumer 信息，同时用来发现 broker 列表，并和 Partition leader 建立 socket 连接获取消息。</p><ul><li>Topic（主题）<ul><li>Kafka 中可将消息分类，每一类的消息称为一个 Topic，消费者可以对不同的 Topic 进行不同的处理。一个topic会被分为若干个partition，每个partition物理上对应一个文件夹   当新消息来时只与partitionLeader 交互，其他分区副本follower从分区副本leader中同步</li></ul></li><li>Broker（代理）<ul><li>每个 Broker 即一个 Kafka 服务实例， 多个 broker 构成一个 Kafka 集群，生产者发布的消息将保存在 Broker 中，消费者将从 Broker 中拉取消息进行消费。</li><li>Broker集群中，会有一个leader（controller leader），负责管理整个集群中分区和副本的状态和选举partition leader</li></ul></li><li>Producer（生产者）<ul><li>负责生产消息并发送给 Broker 。属于客户端</li></ul></li><li>Consumer（生产者）<ul><li>负责消费 Broker 中 Topic 消息，每个 Consumer 实例归属于一个 Consumer Group. 属于客户端</li></ul></li><li>Partition（分区）<ul><li>Partition 是 Kafka 中比较特色的部分，一个 Topic 可以分为多个 Partition，每个 Partition 是一个有序的队列，Partition 中的每条消息都存在一个有序的偏移量（Offest） ，同一个 Consumer Group 中，只有一个 Consumer 实例可消费某个 Partition 的消息。</li><li>partion可以看作一个有序的队列，里面的数据是储存在硬盘中的，追加式的。partition的作用就是提供分布式的扩展，一个topic可以有许多partions，多个partition可以并行处理数据，所以可以处理相当量的数据。只有partition的leader才会进行读写操作，folower仅进行复制，客户端是感知不到的。</li></ul></li><li>ISR<ul><li>lSR指的是能够和leader保持同步的follower+leader本身组成的集合  即所有副本的列表. 副本follower broker会自动同步lead的分区数据，副本leader写入数据后并不会commit，只有ISR列表中的所有folower同步之后才会commit，滞后的follower移除ISR来避免写消息延迟。设置ISR主要是为了broker宕掉之后，重新选举partition的leader从ISR列表中选择。 即每个broker上的分区数据相同</li></ul></li><li>HW<ul><li>high watermark(高水位)，指代的是已提交消息末尾（即可被消费消息的末尾）。消息进入kafka后当所有节点的已经完成同步后的位置被称为HW, 所有进入的消息的末尾称为Log end offset.</li></ul></li></ul><p> Broker 泛指kafka的服务端  通常是一个或多个物理机器，broker通常指kafka服务端一个节点。Producer和Consumer属于客户端</p><p>broker-list是老版的指代集群服务端地址的，bootstrap.servers是新版的。（由于兼容性问题有的地方并没有替换该命令）</p><p>另外指定kafka集群时只需填写一个  broker地址，kafka会自动寻找其他broker</p><h2 id="2种leader"><a href="#2种leader" class="headerlink" title="2种leader"></a>2种leader</h2><p>kafka集群中有2个种leader，一种是broker leader即controller leader，还有一种就是partition的leader，2种leader的选举大致流程</p><h3 id="Controller-leader（集群leader）"><a href="#Controller-leader（集群leader）" class="headerlink" title="Controller leader（集群leader）"></a>Controller leader（集群leader）</h3><p>当broker启动的时候，都会创建KafkaController对象，每个节点上的KafkaController会在指定的zookeeper路径下创建临时节点，第一个成功创建的节点的KafkaController才可以成为leader，其余的都是follower。当leader故障后，所有的follower会收到通知，再次竞争在该路径下创建节点从而选举新的leader</p><p>  所有brokers选举出一个leader controller  .  <strong>只有 leader broker在监听zk,其他broker只需与leader broker通信.</strong></p><h3 id="Partition-leader（分区副本leader）"><a href="#Partition-leader（分区副本leader）" class="headerlink" title="Partition leader（分区副本leader）"></a>Partition leader（分区副本leader）</h3><p> 由controller leader执行</p><div class="code-wrapper"><pre><code class="hljs"> 1. 从Zookeeper中读取当前分区的所有ISR集合 2. 调用配置的分区算法选择分区的leader （有多种算法） 3. 监听 Partition leader 存活状态 4. follower节点复制分区leader的副本</code></pre></div><p>  举例：有3个broker   设置分区数为3  副本数为3       </p><p>​     则共有9个分区副本    假定 broker1当选 leader,    经过选举 </p><p>​           分区1的leader副本在broker1</p><p>​           分区2的leader副本在broker2</p><p>​           分区3的leader副本在broker3</p><p>​    当消息写入分区1 ，broker2,3会从broker1上同步分区1</p><p>​    当消息写入分区2  , broker1,3会从broker2上同步分区2</p><p>​     ……</p><p><strong>不同分区的leader 可以在一个broker上也可以不在（默认分区leader都在broker leader上），主要取决于分区选举算法</strong></p><p><strong>出于高可用的考虑，kafka默认会确保分区的每个副本被放在不同的broker上</strong></p><h2 id="生产消费流程"><a href="#生产消费流程" class="headerlink" title="生产消费流程"></a>生产消费流程</h2><h3 id="producer-的写入流程"><a href="#producer-的写入流程" class="headerlink" title="producer 的写入流程"></a>producer 的写入流程</h3><ol><li>producer 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader </li><li>producer 将消息发送给该partition  leader </li><li>leader 将消息写入本地 log </li><li>followers 从 leader pull 消息，写入本地 log 后 leader 发送 ACK 确认</li><li>leader 收到所有 ISR 中的 broker 的 ACK 后，增加 HW（high watermark，已经 commit 消息的 offset） 并向 producer 发送 ACK</li></ol><h3 id="consumer消费流程"><a href="#consumer消费流程" class="headerlink" title="consumer消费流程"></a>consumer消费流程</h3><p>​     kafka采用pull模式进行消费消息，上次消费的offset保存于zk.</p><p>注意：<br> 1、如果消费线程大于 Patition 数量，则有些线程将收不到消息。<br> 2、如果 Patition 数量大于消费线程数，则有些线程多收到多个 Patition 的消息。<br> 3、如果一个线程消费多个 Patition，则无法保证你收到的消息的顺序，而一个 Patition 内的消息是有序的。</p><h2 id="ZK在Kafka中的作用"><a href="#ZK在Kafka中的作用" class="headerlink" title="ZK在Kafka中的作用"></a>ZK在Kafka中的作用</h2><h3 id="1、Broker注册"><a href="#1、Broker注册" class="headerlink" title="1、Broker注册"></a>1、Broker注册</h3><p><strong>Broker是分布式部署并且相互之间相互独立，但是需要有一个注册系统能够将整个集群中的Broker管理起来</strong>，此时就使用到了Zookeeper。在Zookeeper上会有一个专门<strong>用来进行Broker服务器列表记录</strong>的节点：</p><p>/brokers/ids</p><p>每个Broker在启动时，都会到Zookeeper上进行注册，即到/brokers/ids下创建属于自己的节点，如/brokers/ids/[0…N]。</p><h3 id="2、Topic注册"><a href="#2、Topic注册" class="headerlink" title="2、Topic注册"></a>2、Topic注册</h3><p>在Kafka中，同一个<strong>Topic的消息会被分成多个分区</strong>并将其分布在多个Broker上，<strong>这些分区信息及与Broker的对应关系</strong>也都是由Zookeeper在维护，由专门的节点来记录，如：</p><p>/borkers/topics</p><h3 id="3、记录消息-消费进度Offset-记录"><a href="#3、记录消息-消费进度Offset-记录" class="headerlink" title="3、记录消息 消费进度Offset 记录"></a>3、记录消息 消费进度Offset 记录</h3><p>0.8及以前在消费者对指定消息分区进行消息消费的过程中，<strong>需要定时地将分区消息的消费进度Offset记录到Zookeeper上</strong></p><p>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><h3 id="4、分区-与-消费者-的关系"><a href="#4、分区-与-消费者-的关系" class="headerlink" title="4、分区 与 消费者 的关系"></a>4、分区 与 消费者 的关系</h3><p>在Kafka中，规定了<strong>每个消息分区 只能被同组的一个消费者进行消费</strong>，因此，需要在 Zookeeper 上记录 消息分区 与 Consumer 之间的关系，每个消费者一旦确定了对一个消息分区的消费权力，需要将其Consumer ID 写入到 Zookeeper 对应消息分区的临时节点上，例如：</p><p>/consumers/[group_id]/owners/[topic]/[broker_id-partition_id]</p><p>其中，[broker_id-partition_id]就是一个 消息分区 的标识，节点内容就是该 消息分区 上 消费者的Consumer ID。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="版本变化"><a href="#版本变化" class="headerlink" title="版本变化"></a>版本变化</h3><p>shell写 消费者命令的变化 </p><p>0.8及以前</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">.\bin\kafka-console-consumer.bat --zookeeper localhost:2181 --topic test<br></code></pre></td></tr></table></figure><p>以后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\bin\\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test<br></code></pre></td></tr></table></figure><p>原因</p><p>0.8以前的kafka，消费的进度(offset)是写在zk中的，所以consumer需要知道zk的地址。后来的版本都由broker管理，所以就用bootstrap-server了。</p><p>新版的 Kafka 使用一个选举出来的 controller 来监听 zookeeper，其他 node 再去和 controller 通信，减少 zookeeper 的压力。</p><p><img src="http://oss.randallstevens.top/kafka1.jpg"></p><p><img src="http://oss.randallstevens.top/kafka2.jpg"></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>监控工具，可视化工具 。如offsetexplorer，雅虎的Kafka Manager，Kafka Web Console</p><p>​       </p>]]></content>
    
    
    
    <tags>
      
      <tag>MQ</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SPI</title>
    <link href="/2022/05/16/Java%20SPI/"/>
    <url>/2022/05/16/Java%20SPI/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-SPI-机制"><a href="#Java-SPI-机制" class="headerlink" title="Java SPI  机制"></a>Java SPI  机制</h1><h2 id="SPI-概述"><a href="#SPI-概述" class="headerlink" title="SPI  概述"></a>SPI  概述</h2><p> SPI全称是Service Provider Interface （服务提供接口），它是jdk6引入的一种服务发现机制。服务提供方通过实现服务方制定的SPI的接口来提供服务；SPI机制负责完成服务发现与注入的职责.     通俗来说就是 服务负责制定标准，服务提供者负责提供符合标准的具体实现.   </p><p> 好处：<strong>spi以一种的插件的形式提供服务，极大的降低了系统的耦合性，增加系统灵活性和可扩展性</strong></p><p>SPI中的角色</p><ul><li>服务方： 即调用方，负责定义标准的spi接口.</li><li>服务提供方：实现标准spi接口的类的一方</li><li>服务加载器 ：发现并加载在运行时环境中的服务提供者</li></ul><p>简单案例：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务制定标准（即提供接口或抽象类）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//服务提供方1</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;wang&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//服务提供方2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shout</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;maio&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//约定 java官方制定的标准</span><br><span class="hljs-comment">//在classpath的根路径下新建 META-INFO/services 目录</span><br><span class="hljs-comment">//新建 全类名限定的服务接口类名文件  spi.demo.service.Animal</span><br><span class="hljs-comment">//在spi.demo.service.Animal中指定服务提供方：</span><br>      spi.demo.provider.Cat<br>      spi.demo.provider.Dog<br>          <br><span class="hljs-comment">//调用方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br>        ServiceLoader&lt;Animal&gt; services= ServiceLoader.load(Animal.class);   <span class="hljs-comment">//服务加载器</span><br>        <span class="hljs-keyword">for</span> (Animal animal:services)&#123;<br>            animal.shout();   <span class="hljs-comment">//分别输出：maio   wang</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理及应用"><a href="#原理及应用" class="headerlink" title="原理及应用"></a>原理及应用</h2><p>​      <strong>SPI机制的原理 即利用服务加载器（类加载器）按照服务提供的标准（接口）加载指定位置的下service provider 提供的服务（标准接口实现类）并将其实例化的过程.</strong></p><p>SPI机制在各大框架中应用广泛。如JDBC,Spring,Dubbo,Flink等.</p><h3 id="举例一：JDBC"><a href="#举例一：JDBC" class="headerlink" title="举例一：JDBC"></a>举例一：JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无SPI机制前JDBC写法</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);  <span class="hljs-comment">//加载驱动类，源码内部会通过静态代码块会自动注册驱动</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, passWd);<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql)<br><span class="hljs-type">int</span> i= statement.executeUpdate();<br><span class="hljs-comment">//有spi机制后 spi自动发现服务并加载</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, passWd); <span class="hljs-comment">//直接获取数据库连接（前提：已引入驱动jar包）</span><br></code></pre></td></tr></table></figure><p>驱动jar结构：java.sql.Driver里的内容 ：com.mysql.cj.jdbc.Driver</p><p><img src="http://oss.randallstevens.top/mysql_spi.png"></p><p>原理：源码简化版</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">DriverManager &#123;<br>   <span class="hljs-comment">//静态代码块注册驱动</span><br>   <span class="hljs-keyword">static</span> &#123;<br>        loadInitialDrivers();  <br>        println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>    &#125;<br>    <br>   <span class="hljs-comment">//静态代码块调用的方法内部</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadInitialDrivers</span><span class="hljs-params">()</span> &#123;<br>      AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//spi机制的体现</span><br>                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>             &#125;<br>   &#125;<br>&#125;                                   <br></code></pre></td></tr></table></figure><h3 id="举例二：Dubbo"><a href="#举例二：Dubbo" class="headerlink" title="举例二：Dubbo"></a>举例二：Dubbo</h3><p>  dubbo的spi实现原理和java spi相似，只不过增强了一些功能和优化。java spi的是把所有的spi都加载到内存，dubbo可以实现按需加载，并且用到缓存技术，极大的提升性能.</p><p>dubbo spi中的注解</p><p>1、@SPI注解，被此注解标记的接口，就表示是一个可扩展的接口，并标注默认值。<br>2、@Adaptive注解，有两种注解方式：一种是注解在类上，一种是注解在方法上。<br>3、@Activate注解，此注解需要注解在类上或者方法上，并注明被激活的条件，以及所有的被激活实现类中的排序信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Factory</span> &#123;<br><br><br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">factoryIdentifier</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a set of &#123;<span class="hljs-doctag">@link</span> ConfigOption&#125; that an implementation of this factory requires in</span><br><span class="hljs-comment">     * addition to &#123;<span class="hljs-doctag">@link</span> #optionalOptions()&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;See the documentation of &#123;<span class="hljs-doctag">@link</span> Factory&#125; for more information.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">ConfigOption</span>&lt;?&gt;&gt; requiredOptions();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a set of &#123;<span class="hljs-doctag">@link</span> ConfigOption&#125; that an implementation of this factory consumes in</span><br><span class="hljs-comment">     * addition to &#123;<span class="hljs-doctag">@link</span> #requiredOptions()&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;See the documentation of &#123;<span class="hljs-doctag">@link</span> Factory&#125; for more information.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-title class_">Set</span>&lt;<span class="hljs-title class_">ConfigOption</span>&lt;?&gt;&gt; <span class="hljs-title function_">optionalOptions</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Java SPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>容器 VS 无服务</title>
    <link href="/2022/05/07/%E6%97%A0%E6%9C%8D%E5%8A%A1%20VS%20%20%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    <url>/2022/05/07/%E6%97%A0%E6%9C%8D%E5%8A%A1%20VS%20%20%E5%AE%B9%E5%99%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="容器-VS-无服务"><a href="#容器-VS-无服务" class="headerlink" title="容器 VS 无服务"></a>容器 VS 无服务</h1><p> 多年以来，我们一直习惯于把应用程序部署在物理服务器之上。而由此带来的资源管理或供应责任自然全部由我们自己承担。这种方式带来了以下几个问题：</p><ul><li>即使完全没有任何负载需求，服务器也在持续运行，因此会消耗大量不必要的资源。</li><li>需要负责完成服务器维护以及正常运行时间保障等日常工作。</li><li>需要负责对服务器进行适当的安全更新。</li><li>随着使用量的增加，我们需要亲自管理服务器扩展工作;与之对应，当工作负载回落，我们又得进行规模收缩。</li></ul><p>面对这么多现实问题，中小型企业乃至个人显然不愿意、甚至没办法投入相应的精力。另外，传统服务器模式的上述特性还会影响产品的整体上市时间与交付成本，而这些正是决定定制化软件开发命运的核心所在。因此产生了新型的部署方式</p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化?"></a>容器化?</h2><p>​       容器化的出现解决了一个重要问题：确保软件在某一计算环境迁移至另一计算环境时，仍能正确运行。容器化应用程序还帮助不同团队得以独立处理应用程序中的不同部分;只要各组件间的交互方式不出现重大变化，各团队就能安心打理自己的环节。如此一来，整个软件开发流程会变得更轻松、开发者也能更快测试一切潜在错误。 （即项目 环境迁移水土不服问题）.</p><p>​      在敏捷化、DevOps的世界中，上述能力的重要意义不言自明。容器能帮助开发者建立起信心，让他们坚信自己的软件在任何环境下都能顺利运行。也正是容器化趋势催生出了当下同样热门的“微服务架构”。</p><p>下面来看容器中常见的几种绑定要素：</p><ul><li>应用程序本体</li><li>依赖项</li><li>库</li><li>二进制文件</li><li>配置文件</li></ul><p>​     但为了管理这些容器，我们还需要仰仗另一套专用软件，例如Docker Swarm、Kubernetes等等。这些软件可以帮助我们编排容器，将其正确推送至不同的目标设备并保证它们在那里顺畅运行。</p><h2 id="无服务"><a href="#无服务" class="headerlink" title="无服务?"></a>无服务?</h2><p>​     “无服务器计算”的概念于是应愿而生。借助无服务器计算，我们可以获得一套执行模型，由云服务商(包括AWS、Azure或者Google Cloud)通过动态分配的资源执行一段段代码。作为用户，我们只需要承担应用程序代码运行所对应的资源用量费用。如果把这种计算成本与传统服务器相比较，我们会发现支出将得到大幅削减。这样，我们的整体计算体验将达成“无服务器”状态(服务器资源的管理成本更低)。所以再次强调，无服务器不是没有服务器——基础设施还在，只是不再困扰我们。</p><h2 id="容器与无服务对比"><a href="#容器与无服务对比" class="headerlink" title="容器与无服务对比"></a>容器与无服务对比</h2><h3 id="1-寿命限制"><a href="#1-寿命限制" class="headerlink" title="1.寿命限制"></a>1.寿命限制</h3><p>无服务器：大家应该了解，函数的寿命往往很“短”。这里的短，一般是在5分钟以内。函数的这种临时特性，意味着运行该函数的容器也会在一次执行之后即告清除。</p><p>但也正是这种较短的生命周期，让函数获得了极高的敏捷性，帮助开发人员得以自由灵活地将应用程序推向各类易于扩展的生产环境。</p><p>容器：容器的情况则有所不同。容器始终保持运行，而且在执行完毕后也不会被消除。这就让容器得以充分利用缓存性能优势，同时被迫放弃了瞬时扩展的能力。</p><h3 id="2-状态持久性"><a href="#2-状态持久性" class="headerlink" title="2. 状态持久性"></a>2. 状态持久性</h3><p>无服务器：如前文所述，函数总是具有临时性或者说“短寿命”特性，这也决定了它们的无状态属性。而函数越是保持这种无状态性，就适合被用来组合并构建起强大的整体解决方案。</p><p>无状态计算的强大之处，在于帮助开发人员编写出众多强大的、可重用的函数并灵活组合起来。但也正是由于这种无状态性，导致函数无法缓存任何内容以供后续使用。没有了缓存机制，其延迟水平也就更高。</p><p>容器：在容器一边，我们倒是可以充分发挥缓存优势。为了保证即使在容器终止后数据仍能正常存储，我们需要一种存储机制来容纳容器之外的数据。说到这里，有些朋友可能要问，缓存有那么重要吗?为什么我们在讨论中总要提起缓存?</p><p>确实重要，因为如果容器将要在目标文件上生成的对象之前就曾经出现过，那么直接重用原有结果能够节约下大量时间。而这些原有结果正是要由缓存来存放。所以在缓存的加持下，新容器能获得极快的构建速度。</p><h3 id="3-无延迟与启动时间"><a href="#3-无延迟与启动时间" class="headerlink" title="3. 无延迟与启动时间"></a>3. 无延迟与启动时间</h3><p>无服务器：函数的无状态与不可缓存两大特性，决定了其必然不具备在待机期间持续运行的函数副本，这就必然导致调用时间更长。所以函数只有两种状态：1)“保温”状态，即代码根据命令执行的15分钟以内;除此之外的任何其他时段皆属于2)冷启动状态。</p><p>结果就是，对于存在众多并发用户的应用场景，无服务器计算必然存在延迟问题。为此，大家可以添加以下代码使得函数始终“保温”。</p><p>但这毕竟只是权宜之计，只适用于函数数量不大的场景。面对数量众多的大规模系统，我们根本无法正确管理所有虚拟函数。所以以上方法只适用于函数数量较少，没必要惊动整体容器的情况。</p><p>容器：容器诞生于前无服务器时代，所以它当然不像无服务器那样“转瞬即逝”。容器就在那里，随时准备着接收我们的HTTPS请求、再以低延迟甚至即时方式做出响应。凭借着缓存优势，容器的启动速度很快、无需重复创建文件，单靠缓存数据引用就足够定位并重用原有结构。</p><h3 id="4-可扩展性"><a href="#4-可扩展性" class="headerlink" title="4. 可扩展性"></a>4. 可扩展性</h3><p>无服务器：在无服务器架构中，应用程序后端会自动且固有地进行扩展以满足负载需求。另外，无服务器计算更像是自来水供应系统：只要服务商把总闸打开，消费者那边就永远会有水可用，且只需要为自己家中龙头里流出的水量付费。相比之下，容器技术则更像是挨家挨户配送的桶装饮用水，在可扩展性上显然不及无服务器计算。</p><p>容器：在使用基于容器的架构时，开发者需要根据需求提前部署相应数量的容器，借此满足应用程序的扩展申请。此外，随着需求量增加，我们往往需要部署更多容器以应对负载波动。而在实际需求超过容器配置预期时，就必然要出现可扩展性瓶颈、且没有很好的即时解决办法。</p><h3 id="5-可移植性与迁移"><a href="#5-可移植性与迁移" class="headerlink" title="5 可移植性与迁移"></a>5 可移植性与迁移</h3><p>无服务器：假定大家已经在使用AWS的多种不同服务，这时候选择Lambda函数肯定是明智之举，因为其能够与其他服务顺畅集成且可支持快速访问。</p><p>即使您并没有使用AWS服务、而且担心供应商锁定问题，也可以通过域映射/DNS变更等方式保证代码中使用的所有API端点和URL始终处于您的控制之下。</p><p>这样我们就可以随时切断特定服务，并将其重新定向至您所选定的其他端点(例如其他FaaS服务商)。这种方式显然比在不受控制或者您无法调整的端点中部署硬编码代码要安全得多。</p><p>但考虑到市面上FaaS服务商众多，大家对供应商锁定问题的担忧也自有道理。以Lambda为例，如果它无法满足您所在地区的特定要求，大家可以执行以下操作。一切Lambda处理程序的代码都应处于隔离状态，仅仅以“垫片”的形式在其他模块/类中充当逻辑。</p><p>这种方式不仅提高了可重用性，而且能够大大降低重构时Lambda迁移的便捷度与直接性。另外，这种方式还有利于支持单元测试。下面来看瘦Lambda处理程序实例：</p><p>说起迁移，目前人们对于如何将FaaS融入现有DevOps框架仍充当争议。组织可能一口气编写了几百个函数，但在一段时间之后再也没人清楚哪些函数中包含着哪些其他函数、又有多少函数仍在正常使用。</p><p>容器：如果大家选择了基于容器的微服务架构，就能享受到由此带来的良好可移植性。我们可以轻松将程序代码从开发者的笔记本电脑处转移到本地数据中心或者不同云服务商的云计算平台，整个过程既不费力也不费神。</p><p>随着企业承担的创新压力越来越大、产品上市时间越来越短，微服务架构的加持能帮助大家快速为应用程序建立起全新版本。因此，如果大家是出于降低迁移难度、使用丰富的容器技术堆栈等目的而决定从单体式应用程序转向容器，那么微服务架构应该是个理想的探索起点。</p><p>然而，在云平台上运行容器时仍然涉及众多依赖项。例如代码升级需要协同规划，具体涵盖容器主机、容器镜像、容器引擎以及容器编排等。</p><p>对于某些需要迁移至微服务形式的遗留应用程序，直接“容器化”所带来的操作难度和成本往往要低于对整体应用程序进行重构。</p><h3 id="6-开发环境与语言支持"><a href="#6-开发环境与语言支持" class="headerlink" title="6. 开发环境与语言支持"></a>6. 开发环境与语言支持</h3><p>无服务器：主流FaaS服务商所能支持的语言种类非常有限，主要有Node.js、Python、Java、C#以及Go(以AWS Lambda为例)。</p><p>容器：容器能为大家提供良好的异构开发环境、供您使用一切您所熟悉的技术堆栈。考虑到如今的开发者往往同时精通多种开发语言，这种广泛的支持性在人员招聘层面往往极具优势。</p><p>如果大家正打算为新项目招聘开发人员，那容器能避免我们过多考虑微服务架构中的语言选择。不同微服务可以独立部署、独立扩展，各服务之间拥有明确的模块边界，不同服务可以由任何语言编写并由不同团队负责管理。</p><h3 id="7-系统控制"><a href="#7-系统控制" class="headerlink" title="7. 系统控制"></a>7. 系统控制</h3><p>无服务器：由于消除了基础设施层面的复杂性，AWS Lambda等FaaS服务中的函数用起来可谓便捷顺滑。这样，大家可以更多专注于产品开发与业务成果实现。也就是说，无服务器计算能够显著缩短产品的上市时间，但容器却不然。但以AWS Lambda为例，无服务器计算在使用时有着诸多注意事项、一旦违反很可能引发问题。</p><p>容器：容器方面的难题主要集中在集群配置上，这些严峻的挑战要求我们具备扎实的容器技术背景。好在微服务层面的控制难度不算很高，而且Kubernetes等编排框架也能帮助我们提高架构的治理与控制效率。</p><p>基于容器的微服务架构让我们掌握了对于容器系统的全面控制权，从而实现策略设置、资源分配与管理。此外，我们还能对安全和迁移服务进行精细化控制。</p><p>而凭借这种完全控制特性，我们可以随时通过容器系统查看容器内外的基本情况，进而跨越多种环境和大量资源开展全面且有效的测试与调试。相比之下，我们无法验证函数的本地实现与测试，所以很难提前判断其运行性能。</p><h3 id="8-高强度资源处理"><a href="#8-高强度资源处理" class="headerlink" title="8. 高强度资源处理"></a>8. 高强度资源处理</h3><p>让我们继续以AWS Lambda为例，如果某一函数的处理时长超过5分名，系统就会要求我们将该任务拆分成多个更小的任务。当然，类似的限制要求还有很多。</p><p>大家最多可以为单一函数分配1.5 GB的内存，而部署包则不能超过50 MB。但在容器方面，我们则可根据应用程序的实际需求随意分配计算资源。</p><h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9. 测试"></a>9. 测试</h3><p>无服务器：我们往往很难对基于无服务器的Web应用程序进行测试，因为开发者通常无法在本地环境中重现这种实际后端环境。</p><p>容器：由于各容器运行在部署时所处的同一平台之上，我们可以相对简单地在生产部署之前对基于容器的应用程序进行各类测试。</p><h3 id="10-维护"><a href="#10-维护" class="headerlink" title="10. 维护"></a>10. 维护</h3><p>无服务器：无服务器类应用程序的维护难度比大多数人想象中低得多。由于无服务器服务商(例如AWS Lambda)一力承担起服务器的管理及软件更新等日常事务，因此整体维护负担会维持在很低的水平。</p><p>容器：与帮助开发者告别维护烦恼的无服务器不同，容器要求开发者们继续承担从管理到更新的所有容器维护工作。</p><h3 id="11-成本比较"><a href="#11-成本比较" class="headerlink" title="11. 成本比较"></a>11. 成本比较</h3><p>无服务器：之前已经提到，使用AWS Lambda等无服务器函数进行应用程序部署能帮助大家摆脱不必要的资源开销，确保应用程序代码只根据调用操作适时运行。这种形式完全不同于以往大家熟悉的无论用不用、都要持续付费的本地基础设施系统。</p><p>容器：容器在成本方面表现得比较传统，同样是在没人用时也始终保持运行，所以客户需要根据服务器空间向云服务商付费。</p><h3 id="12-部署时间"><a href="#12-部署时间" class="headerlink" title="12. 部署时间"></a>12. 部署时间</h3><p>无服务器： 由于无服务器函数在体量上小于容器微服务，而且其中不捆绑任何系统依赖项，所以每款应用程序的部署时长只需要几毫秒。另外，无服务器应用程序能够在代码部署完成后立即上线。</p><p>容器：虽然容器的初始设置时间较长，但在全面配置设定完成之后，后续部署也能在几秒内结束。</p><h2 id="容器与无服务选择"><a href="#容器与无服务选择" class="headerlink" title="容器与无服务选择"></a>容器与无服务选择</h2><h3 id="什么时候选无服务器-：无服务器用例解析"><a href="#什么时候选无服务器-：无服务器用例解析" class="headerlink" title="什么时候选无服务器?：无服务器用例解析"></a>什么时候选无服务器?：无服务器用例解析</h3><p>无服务器计算特别适合以下用例：</p><ul><li>如果您的流量模式会自动变化，那么无服务器计算不仅能自动消解波动、还能在没有流量时暂时关闭。</li><li>如果大家担心服务器的维护成本以及应用程序消耗的资源，那就表明您适合选择无服务器计算。</li><li>如果您不想花太多时间思考代码在哪里运行、具体怎么运行，请选择无服务器。</li><li>无服务器网站与应用程序的编写与部署流程不涉及任何基础设施设置环节。因此，我们可以在几天之内通过无服务器计算构建起功能完备的应用程序或网站。</li><li>无服务器架构允许您为应用程序构建起各类性能强劲的图像与视频服务。您可以使用这些服务动态调整图像大小，或者针对不同类型的目标设备执行视频转码等。</li></ul><h3 id="什么时候选容器-：容器用例解析"><a href="#什么时候选容器-：容器用例解析" class="headerlink" title="什么时候选容器?：容器用例解析"></a>什么时候选容器?：容器用例解析</h3><p>以下几种应用程序部署需求特别适合选择容器技术：</p><ul><li><p>如果您想要自主选择操作系统，并充分控制其中安装的编程语言和运行时版本。</p></li><li><p>如果您打算使用某些软件的特定版本，那容器也是最好的选择。</p></li><li><p>如果您之前一直在使用传统大型服务器来处理Web API、机器学习计算以及其他各种需要长时间运行的业务流程，不妨试试容器——运行效果基本一样，而成本却较传统服务器更低。</p></li><li><p>如果您打算开发新的容器原生应用程序。</p></li><li><p>如果您打算对某款体量庞大且极为复杂的单体式应用程序进行重构，那最好选择容器——容器更适合复杂的应用结构。</p></li><li><p>有些组织也在使用容器将现有应用程序直接迁移至更为现代的环境当中。Kubernetes等容器编排工具包含一系列明确的已知最佳实践，能够轻松管理大规模容器设置。</p></li><li><p>Docker等容器编排平台能够通过自动规模伸缩解决流量无法预测的问题(但请注意，容器的规模伸缩过程无法即时完成)。</p><h3 id="什么时候选无服务器-：无服务器用例解析-1"><a href="#什么时候选无服务器-：无服务器用例解析-1" class="headerlink" title="什么时候选无服务器?：无服务器用例解析"></a>什么时候选无服务器?：无服务器用例解析</h3><p>无服务器计算特别适合以下用例：</p><ul><li>如果您的流量模式会自动变化，那么无服务器计算不仅能自动消解波动、还能在没有流量时暂时关闭。</li><li>如果大家担心服务器的维护成本以及应用程序消耗的资源，那就表明您适合选择无服务器计算。</li><li>如果您不想花太多时间思考代码在哪里运行、具体怎么运行，请选择无服务器。</li><li>无服务器网站与应用程序的编写与部署流程不涉及任何基础设施设置环节。因此，我们可以在几天之内通过无服务器计算构建起功能完备的应用程序或网站。</li><li>无服务器架构允许您为应用程序构建起各类性能强劲的图像与视频服务。您可以使用这些服务动态调整图像大小，或者针对不同类型的目标设备执行视频转码等。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>服务部署</tag>
      
      <tag>容器化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot 自动配置原理</title>
    <link href="/2022/04/27/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/04/27/SpringBoot%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h1><p>自动配置：基于引入的jar包，根据自动配置类,将引入的类注册进ioc容器.</p><p>配置类的定义：</p><ul><li>广义  ：被@Component直接或间接修饰的类，包括@Configuration,@Bean (即注册进容器的所有组件类)</li><li>狭义  ：被 @Configuration修饰的类</li></ul><p>首先 自动配置的前提是导入配置类（配置类本身也是一个bean）</p><h2 id="SpringBoot启动流程："><a href="#SpringBoot启动流程：" class="headerlink" title="SpringBoot启动流程："></a>SpringBoot启动流程：</h2><p>​            SpringBoot实际启动流程非常的复杂，此处为简化后步骤代码版：</p><p><img src="http://oss.randallstevens.top/springboot_%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B_%E4%BB%A3%E7%A0%81.png" alt="启动流程_代码"></p><p>​             启动流程图</p><img src="http://oss.randallstevens.top/springboot_%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="启动流程_图" style="zoom:85%;" /><p>​                 上述启动流程的第三步详细过程代码：</p><p><img src="http://oss.randallstevens.top/springboot_%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B_%E4%BB%A3%E7%A0%81.png" alt="自动配置流程_代码"></p><p>   自动配置流程图：递归加载所有配置类，注册组件进IOC容器</p><p><img src="http://oss.randallstevens.top/springboot_%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B_%E5%9B%BE.png" alt="自动配置流程_图"></p><h2 id="自动配置前置知识"><a href="#自动配置前置知识" class="headerlink" title="自动配置前置知识"></a>自动配置前置知识</h2><h3 id="1-ComponentScan和-Import"><a href="#1-ComponentScan和-Import" class="headerlink" title="1. @ComponentScan和@Import"></a><strong>1. @ComponentScan和@Import</strong></h3><p>​           通过SpringBoot启动流程,可以发现其底层是通过 @ComponentScan 和 @Import 导入组件进容器的      </p><p>​                 @ComponentScan         通过 basePackage指定扫描路径，默认为当前包及其子包.</p><p>​                 @Import导入组件的形式     1. 导入普通类  2.导入 “导入选择器”   3.导入 “导入bean定义注册器”</p><p>@Import导入形式一</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@Import(&#123;Cat.class&#125;)</span>   <span class="hljs-comment">//导入的bean的beanname为全类名</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ioc</span> <span class="hljs-operator">=</span> SpringApplication.run(MyApplication.class);<br>         <span class="hljs-type">boolean</span> result= ioc.containsBean(<span class="hljs-string">&quot;com.xxx.Cat&quot;</span>);<br>         System.out.println(result);  <span class="hljs-comment">//True</span><br>    &#125;<br>&#125;       <br></code></pre></td></tr></table></figure><p><strong>@Import导入形式二</strong> ：Springboot底层就通过这种方式加载自带的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Tiger <span class="hljs-title function_">tiger</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span>&#123;   <span class="hljs-comment">//  实现ImportSelector重写selectImports()</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.xxx.ZooConfig&quot;</span>&#125;;  <span class="hljs-comment">//会将配置类自身及其内部@Bean的组件都注册进IOC容器</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">//导入方式和导入普通类形式一致： </span><br><span class="hljs-meta">@Import(&#123;ZooImportSelector&#125;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>@Import导入形式三：,如mybtis导入带@mapper注解的代理对象,</p><p>官方该方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZooRegister</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;  <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span>      &#123;<br>        <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">dogDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();  <span class="hljs-comment">//创建泛型bean定义</span><br>        dogDefinition.setBeanClass(Tiger.class);    <span class="hljs-comment">//填充类进bean定义</span><br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;dog&quot;</span>,dogDefinition); <span class="hljs-comment">//注册bean</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//导入方式和导入普通类形式一致： @Import(&#123;ZooRegister&#125;)</span><br></code></pre></td></tr></table></figure><h3 id="2-SpringFactories-机制（spring-spi）"><a href="#2-SpringFactories-机制（spring-spi）" class="headerlink" title="2.SpringFactories 机制（spring  spi）"></a>2.SpringFactories 机制（spring  spi）</h3><p>​      前面提到Springboot是通过 实现importSelector接口来实现导入配置，注册bean的。</p><p>​      因此如何实现  AutoConfigurationImportSelector.class 是实现自动配置的基础.</p><p>   <strong>SpringFactories</strong> 机制：</p><div class="code-wrapper"><pre><code class="hljs">     -  是SPI机制的延伸 （Service Provider Interface ： 服务提供接口）      -  spring框架的基础     -  spring boot基于此实现自动配置</code></pre></div><p>SpringFactories 核心逻辑是从classpath下读取jar包的 META-INFO目录下的spring.factories下读取所有的自动配置类路径</p><p><strong>SPI机制和springfactories机制对比</strong></p><p><img src="http://oss.randallstevens.top/springboot_spi%E5%AF%B9%E6%AF%94.png"></p><h3 id="3-按需加载"><a href="#3-按需加载" class="headerlink" title="3.按需加载"></a>3.按需加载</h3><p>​      Springboot加载自动配置类并不会将所有配置，而是会通过@Conditional及其衍生注解，判断满足特定的条件才会加载该自动配置类进而进行创建bean. 达到按需加载的目的，避免了组件的的冗余.</p><p>常见@Conditional衍生注解：</p><p><img src="http://oss.randallstevens.top/springboot_Conditional.png"></p><h2 id="自动配置源码分析"><a href="#自动配置源码分析" class="headerlink" title="自动配置源码分析"></a>自动配置源码分析</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>   @SpringbootApplication注解 是实现springboot自动配置的起源和核心</p><p>   @SpringBootApplication = @SpringBootConfiguration +  @EnableAutoConfiguration + @ComponentScan</p><ol><li><p>@SpringBootConfiguration  等价于@Configuration注解,表明当前类是一个配置类</p></li><li><p>@ComponentScan  包扫描   未指明basePackage时，默认为当前包</p></li><li><p><strong>@EnableAutoConfiguration</strong>   <em>开启自动配置  ？</em>   (完全拆解后等于两个@import)   </p><p>  该注解是一个合成注解 等价于  @AutoConfigurationPackage + @Import(AutoConfigurationImportSelector.class)</p><p> ​                   </p><p>  @AutoConfigurationPackage 自动配置包？将注解扫描到的组件注册进容器（默认为当前）</p></li></ol><p>   ​           其底层其实是通过@Import注解导入一个 BeanDefinitionRegistrar 注册当前包下类进IOC容器</p><div class="code-wrapper"><pre><code class="hljs">**@Import(AutoConfigurationImportSelector.class)**    导入一个ImportSelector加载所有自动配置类  </code></pre></div><p>   此步为自动配置最<strong>核心步骤</strong></p><p>   AutoConfigurationImportSelector.class类（ 部分）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> &#123;   <br>  <span class="hljs-comment">//1.选择要导入的组件 通过该方法注册自动配置类进容器</span><br>  <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-comment">//***关键调用处：获取自动配置类入口  </span><br><span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br><span class="hljs-comment">//2. 获取所有待选的自动配置类，去重，移除不自动配置的，过滤等 返回要自动配置的类</span><br>    <span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br><span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);<br>        <span class="hljs-comment">//***关键调用处：获取所有的待选配置</span><br>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>configurations = removeDuplicates(configurations);<br>Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>checkExcludedClasses(configurations, exclusions);<br>configurations.removeAll(exclusions);<br>configurations = getConfigurationClassFilter().filter(configurations);<br>fireAutoConfigurationImportEvents(configurations, exclusions);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>&#125;<br>    <span class="hljs-comment">//3. SpringFactoriesLoader 加载所有的自动配置类</span><br>    <span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;<br>        <span class="hljs-comment">//*** 关键调用处：获取配置</span><br>List&lt;String&gt; configurations =SpringFactoriesLoader.loadFactoryNames(                                                    (getSpringFactoriesLoaderFactoryClass(),getBeanClassLoader());<br><span class="hljs-keyword">return</span> configurations;<br>&#125;<br>&#125;                                                                            <br></code></pre></td></tr></table></figure><p>   SpringFactoriesLoader.class源码（ 部分）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//4.SpringFactoriesLoader 规定类 加载的位置</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringFactoriesLoader</span> &#123;<br>     <span class="hljs-comment">//资源位置定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FACTORIES_RESOURCE_LOCATION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> classLoader;<br><span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> factoryType.getName();<br>        <span class="hljs-comment">//*** 关键调用处：加载SpringFactories</span><br><span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());<br>&#125;<br>       <span class="hljs-comment">//***最终调用处：获取META-INF/spring.factories内容 返回列表</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>          Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);      <br>     &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>  <img src="http://oss.randallstevens.top/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%85%A8%E6%B5%81%E7%A8%8B.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 日志</title>
    <link href="/2022/04/17/Java%20%E6%97%A5%E5%BF%97/"/>
    <url>/2022/04/17/Java%20%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Java日志"><a href="#Java日志" class="headerlink" title="Java日志"></a>Java日志</h1><p>日志的作用：</p><ul><li>方便调试，理解程序运行流程</li><li>便于发现系统运行过程中的错误</li><li>存储数据，便于后期分析</li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>​      最先出现的日志框架 Log4j，这个框架是早期应用最广泛的日志工具，现在仍在大量使用。，后来Sun 公司认为自己才是正统，在 JDK 1.4 中增加了 JUL（在 java.util.logging 包下）日志实现，企图对抗 Log4j，却造成了 Java 日志记录的混乱。</p><p>​      为了统一日志的标准，Apache 开源社区提供了一个日志框架作为日志的抽象（日志门面），叫 commons-logging，也被称为 JCL，JCL 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都进行适配，这样这些提供给别人的库都直接使用抽象层即可，可以兼容主流的日志实现（Log4j、JUL、Simplelog 等）。但Log4j 的作者，他觉得 JCL 不够优秀，于是自己又开发了新的日志门面SLF4J，并为 SLF4J 提供了一个具体实现了logback。再后来apache由于log4j的性能问题开发出了新的日志框架log4j2。</p><p>​      log4j   –&gt;   jul  –&gt;  jcl    –&gt;   slf4j+logback  —&gt;  log4j2 </p><h2 id="使用演示"><a href="#使用演示" class="headerlink" title="使用演示"></a>使用演示</h2><blockquote><h3 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h3><p>官方日志框架（仅做了解，几乎不会使用）</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJUL</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> Logger.getLogger(TestJUL.class.toString());  <span class="hljs-comment">//日志对象</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String  <span class="hljs-title function_">getInfo</span><span class="hljs-params">(String info)</span> &#123;<br>       <span class="hljs-keyword">if</span> (info.isEmpty())&#123;<br>           log.log(Level.WARNING,<span class="hljs-string">&quot;信息为空&quot;</span>);   <span class="hljs-comment">//设置日志等级及输出信息</span><br>       &#125;<br>       <span class="hljs-keyword">return</span> info;<br>   &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> getInfo(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(info);<br>    &#125;<br>&#125;<br>控制台输出：<br>    四月 <span class="hljs-number">25</span>, <span class="hljs-number">2022</span> <span class="hljs-number">1</span>:<span class="hljs-number">20</span>:<span class="hljs-number">20</span> 上午 log.entity.jul.TestJUL getInfo<br>    警告: 信息为空<br>    <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>设置配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### 设置###</span><br><span class="hljs-attr">log4j.rootLogger</span> = <span class="hljs-string">debug,stdout,D,E</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">### 输出信息到控制抬 ###</span><br><span class="hljs-attr">log4j.appender.stdout</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-attr">log4j.appender.stdout.Target</span> = <span class="hljs-string">System.out</span><br><span class="hljs-attr">log4j.appender.stdout.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.stdout.layout.ConversionPattern</span> = <span class="hljs-string">[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><br><span class="hljs-attr">log4j.appender.D</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><br><span class="hljs-attr">log4j.appender.D.File</span> = <span class="hljs-string">E://logs/log.log</span><br><span class="hljs-attr">log4j.appender.D.Append</span> = <span class="hljs-string">true</span><br><span class="hljs-attr">log4j.appender.D.Threshold</span> = <span class="hljs-string">DEBUG</span><br><span class="hljs-attr">log4j.appender.D.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.D.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br><span class="hljs-attr">log4j.appender.E</span> = <span class="hljs-string">org.apache.log4j.DailyRollingFileAppender</span><br><span class="hljs-attr">log4j.appender.E.File</span> =<span class="hljs-string">E://logs/error.log</span><br><span class="hljs-attr">log4j.appender.E.Append</span> = <span class="hljs-string">true</span><br><span class="hljs-attr">log4j.appender.E.Threshold</span> = <span class="hljs-string">ERROR</span><br><span class="hljs-attr">log4j.appender.E.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-attr">log4j.appender.E.layout.ConversionPattern</span> = <span class="hljs-string">%-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLog4j</span> &#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(TestLog4j.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;This is debug message.&quot;</span>);<br>        logger.info(<span class="hljs-string">&quot;This is info message.&quot;</span>);<br>        logger.error(<span class="hljs-string">&quot;This is error message.&quot;</span>);<br>    &#125;<br>&#125;                                                                                                           <br></code></pre></td></tr></table></figure><p>​     </p><h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h3><p>  由于jcl的标准几乎不会使用，所以不做演示。</p><p> Slf4j是仅是一个日志门面（或者称之为标准），需要依赖于具体的日志实现。这里仅作Slf4j+logback使用的简单演示</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     //简化开发，非必须<br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>slf4j+logback  使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span>  <span class="hljs-comment">//lombok注解 动态生成日志对象 等价于第3行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLogback</span> &#123;<br>    <span class="hljs-comment">//static Logger log = LoggerFactory.getLogger(TestLogback.class);</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;this is info message&quot;</span>);<br>        log.error(<span class="hljs-string">&quot;this is error message&quot;</span>);<br>        log.debug(<span class="hljs-string">&quot;this is debug message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>slf4j+log4j2  依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j2核心两个包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- slf4j核心API --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 用于桥接slf4j --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用：因为都是slf4j标准，故使用和上面的slf4j+logback一样.</p></blockquote><h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><blockquote><h3 id="log4j"><a href="#log4j" class="headerlink" title="log4j:"></a>log4j:</h3><p>模板:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#配置根Logger</span><br><span class="hljs-attr">log4j.rootLogger</span>  =   <span class="hljs-string">[ level ]   ,  appenderName1 ,  appenderName2 ,  …</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#配置日志信息输出目的地Appender</span><br><span class="hljs-attr">log4j.appender.appenderName</span>  =  <span class="hljs-string">fully.qualified.name.of.appender.class </span><br><span class="hljs-attr">　　log4j.appender.appenderName.option1</span>  =  <span class="hljs-string">value1 </span><br><span class="hljs-attr">　　log4j.appender.appenderName.optionN</span>  =  <span class="hljs-string">valueN </span><br><br><span class="hljs-attr">eg</span>: <span class="hljs-string">log4j.appender.logToFile  = org.apache.log4j.FileAppender</span><br>    <span class="hljs-attr">log4j.appender.logToFile.File</span>=<span class="hljs-string">&quot;E/log&quot;</span><br><span class="hljs-comment">#配置日志信息的格式（布局）</span><br><span class="hljs-attr">log4j.appender.appenderName.layout</span>  =  <span class="hljs-string">fully.qualified.name.of.layout.class </span><br><span class="hljs-attr">　　log4j.appender.appenderName.layout.option1</span>  =  <span class="hljs-string">value1 </span><br><span class="hljs-attr">　　…</span> <span class="hljs-string"></span><br><span class="hljs-attr">　　log4j.appender.appenderName.layout.optionN</span>  =  <span class="hljs-string">valueN </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#日志等级</span><br><span class="hljs-attr">FATAL</span>      <span class="hljs-string">0  </span><br><span class="hljs-attr">ERROR</span>      <span class="hljs-string">3  </span><br><span class="hljs-attr">WARN</span>       <span class="hljs-string">4  </span><br><span class="hljs-attr">INFO</span>       <span class="hljs-string">6  </span><br><span class="hljs-attr">DEBUG</span>      <span class="hljs-string">7 </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#Appender类型 日志输出目的地</span><br><span class="hljs-attr">org.apache.log4j.ConsoleAppender（控制台），</span><br><span class="hljs-attr">org.apache.log4j.FileAppender（文件），</span><br><span class="hljs-attr">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），</span><br><span class="hljs-attr">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），</span><br><span class="hljs-attr">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br><span class="hljs-comment">#  输出格式</span><br><span class="hljs-attr">org.apache.log4j.HTMLLayout（以HTML表格形式布局），</span><br><span class="hljs-attr">org.apache.log4j.PatternLayout（可以灵活地指定布局模式），</span><br><span class="hljs-attr">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），</span><br><span class="hljs-attr">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br><br></code></pre></td></tr></table></figure><h3 id="logj4j2"><a href="#logj4j2" class="headerlink" title="logj4j2:"></a>logj4j2:</h3><p>支持 XML、JSON、YAML 或者 properties 格式的配置文件.也可在内部 Logger 类上调用方法来设置配置.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!--status:Log4j2内部日志的输出级别,设置为TRACE对学习Log4j2非常有用 --&gt;</span><br><span class="hljs-comment">&lt;!--monitorInterval:定时检测配置文件的修改,有变化则自动重新加载配置,时间单位为秒,最小间隔为5s --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;600&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--properties:设置全局变量 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--LOG_HOME:指定当前日志存放的目录 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_HOME&quot;</span>&gt;</span>logs<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--FILE_NAME:指定日志文件的名称 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_NAME&quot;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-comment">&lt;!--Appenders:定义日志输出目的地，内容和格式等 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Console:日志输出到控制台标准输出 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--pattern:日期,线程名,日志级别,日志名称,日志信息,换行 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level [%L] - %msg%n&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--RollingFile:日志输出到文件,下面的文件都使用相对路径 --&gt;</span><br>  <span class="hljs-comment">&lt;!--fileName:当前日志输出的文件名称 --&gt;</span><br>  <span class="hljs-comment">&lt;!--filePattern:备份日志文件名称，备份目录为logs下面以年月命名的目录，备份时使用gz格式压缩 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFile&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/$&#123;FILE_NAME&#125;.log&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;/$&#123;FILE_NAME&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level [%L] - %msg%n&quot;</span> /&gt;</span><br>      <span class="hljs-comment">&lt;!--Policies:触发策略决定何时执行备份 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span><br>          <span class="hljs-comment">&lt;!--TimeBasedTriggeringPolicy:日志文件按照时间备份 --&gt;</span><br>          <span class="hljs-comment">&lt;!--interval:每1天生成一个新文件，时间单位需要结合filePattern时间%d&#123;yyyy-MM-dd&#125; --&gt;</span><br>          <span class="hljs-comment">&lt;!--同理，如果要每1小时生成一个新文件，则改成%d&#123;yyyy-MM-ddHH&#125; --&gt;</span><br>          <span class="hljs-comment">&lt;!--modulate:对备份日志的生成时间纠偏，纠偏以0为基准进行，&quot;0+interval&quot;决定启动后第一次备份时间 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> <span class="hljs-attr">interval</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">modulate</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>          <span class="hljs-comment">&lt;!--SizeBasedTriggeringPolicy:日志文件按照大小备份 --&gt;</span><br>          <span class="hljs-comment">&lt;!--size:指定日志文件最大为100MB，单位可以为KB、MB或GB --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;100MB&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--DefaultRolloverStrategy:翻转策略决定如何执行备份 --&gt;</span><br>      <span class="hljs-comment">&lt;!--max:最多保存5个备份文件，结合时间使用后，在每个时间段内最多有5个备份，多出来的会被覆盖 --&gt;</span><br>      <span class="hljs-comment">&lt;!--compressionLevel:配置日志压缩级别，范围0-9，0不压缩，1压缩速度最快，9压缩率最好，目前只对于zip压缩文件类型有效 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;5&quot;</span> <span class="hljs-attr">compressionLevel</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>          <span class="hljs-comment">&lt;!--Delete:删除匹配到的过期备份文件 --&gt;</span><br>          <span class="hljs-comment">&lt;!--maxDepth:由于备份文件保存在$&#123;LOG_HOME&#125;/$$&#123;date:yyyy-MM&#125;,所以目录深度设置为2 --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">Delete</span> <span class="hljs-attr">basePath</span>=<span class="hljs-string">&quot;$&#123;LOG_HOME&#125;&quot;</span> <span class="hljs-attr">maxDepth</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>              <span class="hljs-comment">&lt;!--IfFileName:匹配文件名称 --&gt;</span><br>              <span class="hljs-comment">&lt;!--glob:匹配2级目录深度下的以.log.gz结尾的备份文件 --&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">IfFileName</span> <span class="hljs-attr">glob</span>=<span class="hljs-string">&quot;*/*.log.gz&quot;</span> /&gt;</span><br>              <span class="hljs-comment">&lt;!--IfLastModified:匹配文件修改时间 --&gt;</span><br>              <span class="hljs-comment">&lt;!--age:匹配超过180天的文件，单位D、H、M、S分别表示天、小时、分钟、秒--&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">IfLastModified</span> <span class="hljs-attr">age</span>=<span class="hljs-string">&quot;180D&quot;</span> /&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">Delete</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">DefaultRolloverStrategy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span><br><span class="hljs-comment">&lt;!--Loggers:定义日志级别和使用的Appenders --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--name: 打印日志的类的包路径 --&gt;</span><br>  <span class="hljs-comment">&lt;!--additivity: true当前的Logger打印的日志附加到Root，false仅仅打印到RollingFile --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache.logging.log4j&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFile&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--Root:日志默认打印到控制台 --&gt;</span><br>  <span class="hljs-comment">&lt;!--level日志级别: ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="logback-配置模板"><a href="#logback-配置模板" class="headerlink" title="logback: 配置模板"></a>logback: 配置模板</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;app_name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;optimus-h5&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;root_dir&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/opt/logs&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">contextName</span>&gt;</span>$&#123;app_name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">contextName</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125;[%line] - %msg%n<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ErrorAppender&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;root_dir&#125;/$&#123;app_name&#125;/error.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;root_dir&#125;/$&#123;app_name&#125;/%d&#123;yyyy-MM-dd&#125;-error.log<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125;[%line] - %msg%n<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 只打印错误日志 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>ERROR<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">onMatch</span>&gt;</span>ACCEPT<span class="hljs-tag">&lt;/<span class="hljs-name">onMatch</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">onMismatch</span>&gt;</span>DENY<span class="hljs-tag">&lt;/<span class="hljs-name">onMismatch</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FrameworkAppender&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.apache&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ErrorAppender&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​       使用slf4j+logback和slf4j+log4j2均可，前者两个适配性更好，后者有更好的性能.</p><p>更多详细配置和原理可以查看官方文档</p><ul><li><a href="(https://www.slf4j.org/)">SLF4J 官网</a></li><li><a href="https://logback.qos.ch/">Logback 官网</a></li><li><a href="https://logging.apache.org/log4j/2.x/">log4j2官网</a> ,  log4j已停止维护</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 注解</title>
    <link href="/2022/04/08/Java%20%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/04/08/Java%20%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​       Java 注解可以通过标注代码（类、接口、方法和字段等）来生成代码的元数据，提供给编译器，框架等来增强代码或实现某些功能.</p><p>​       获取注解元数据：可以通过反射机制实现对这些元数据的访问。另外，还可以指定注解的生命周期，来选择它存在的阶段（SOURCE/CLASS/RUNTIME）</p><p>​         注解是增强型的注释，本质是接口，注解本身不会对代码功能产生影响.</p><p>注解的主要作用</p><ul><li>编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查。</li><li>代码分析：通过代码里标识的元数据对代码进行分析。如spring中通过注解注册bean</li><li>编写文档：通过代码里标识的元数据生成文档。</li></ul><p><strong>元注解</strong>：java内置的四个元注解，即可以用来修饰其他注解的注解</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span>     <span class="hljs-comment">//标记这些注解是否包含在用户文档中(提供元信息给javadoc或其他文档)</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span>             <span class="hljs-comment">//指定作用域</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span>       <span class="hljs-comment">//生命周期</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">//标记这个注解是继承于某个注解(默认 注解并没有继承于任何子类)</span><br><span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>   <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//注解的属性 类似于接口中声明方法 ,注解属性若不指定默认值则在使用时必须指定</span><br>   <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//当仅有一个属性值需要指定且名为value时，使用时可以不写value=</span><br><br>    String[] name() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;   <span class="hljs-comment">//提供属性默认值</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>常见内置注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Deprecated</span>，<span class="hljs-meta">@Override</span>， <span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-meta">@Repeatable</span>   <span class="hljs-comment">//指定注解可以重复使用 。</span><br><span class="hljs-meta">@SafeVarargs</span>    <span class="hljs-comment">//用于方法或构造函数，抑制关于不可具体化变量类型的未检查警告。</span><br><span class="hljs-meta">@SuppressWarnings</span>  <span class="hljs-comment">//用来抑制编译器警告。</span><br></code></pre></td></tr></table></figure><p>注解属性支持的数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">-String<br>-Class<br>-<span class="hljs-keyword">enum</span><br>-Annotation<br>-上面类型的数组<br></code></pre></td></tr></table></figure><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>​     如果仅仅是写一个自定义注解，是没有什么实际意义的。通常是将获取的注解信息配合框架等工具来使用。   </p><ul><li>利用已有框架，不需要自己实现相关逻辑(或需要自己实现部分逻辑，但不涉及反射）。如配合SpringBoot的注解，形成自己的注解（相关的逻辑由SpringBoot自己处理）</li><li>自己实现  自定义注解+获取注解元数据+通过元数据实现的代码逻辑.  如动态代理AOP.</li></ul><p><strong>获取自定义注解的信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnnotation &#123;<br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">AnnotationTest</span>&#123;<br>    <span class="hljs-meta">@MyAnnotation(description = &quot;用户名&quot;,length = 12)</span><br>    <span class="hljs-keyword">private</span>  String  username;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> AnnotationTest.class.getDeclaredField(<span class="hljs-string">&quot;username&quot;</span>);   <span class="hljs-comment">//利用反射获取字节码对象的属性</span><br>        <span class="hljs-type">MyAnnotation</span> <span class="hljs-variable">annoInfo</span> <span class="hljs-operator">=</span> username.getAnnotation(MyAnnotation.class);   <span class="hljs-comment">//获取字段上的注解信息</span><br>        System.out.println(<span class="hljs-string">&quot;注解属性description:&quot;</span>+annoInfo.description());  <span class="hljs-comment">//输出：注解属性description：用户名</span><br>        System.out.println(<span class="hljs-string">&quot;注解属性length:&quot;</span>+annoInfo.length());            <span class="hljs-comment">//输出：注解属性length12</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="注解实现原理"><a href="#注解实现原理" class="headerlink" title="注解实现原理"></a>注解实现原理</h2><p>　   注解本质是一个实现了Annotation接口的 的一个抽象类，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p><h2 id="注解扫描实现"><a href="#注解扫描实现" class="headerlink" title="注解扫描实现"></a>注解扫描实现</h2><p>​    实现扫描指定包获取指定注解的信息 可以通过自定义工具类和利用现成类库两种方式。</p><ol><li> 自定义工具类方式：直接寻找现成工具类,进行修改，此处不再写。</li><li>利用第三方类库。如<ul><li>io.github.classgraph.ClassGraph</li><li>Reflections</li><li>Spring has built-in classpath scanning</li><li>annotation-detector</li></ul></li></ol><p>  此处为ClassGraph的扫描类注解使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;AnnotationParameterValueList&gt; <span class="hljs-title function_">classAnnotionScan</span><span class="hljs-params">(String pkg, String fullPathAnnotation)</span> &#123;<br>        <span class="hljs-type">ScanResult</span> <span class="hljs-variable">scanResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassGraph</span>()     <span class="hljs-comment">//扫描结果</span><br>                .enableAllInfo()                      <span class="hljs-comment">//此处还支持仅扫描类，方法，注解，jar包等</span><br>                .acceptPackages(pkg)                 <span class="hljs-comment">//指定包路径</span><br>                .scan();<br>        <span class="hljs-type">ClassInfoList</span> <span class="hljs-variable">allClasses</span> <span class="hljs-operator">=</span> scanResult.getAllClasses();  <span class="hljs-comment">//获取所有类</span><br>        <span class="hljs-comment">//获取含有指定注解的类列表</span><br>        <span class="hljs-type">ClassInfoList</span> <span class="hljs-variable">classesWithAnnotation</span> <span class="hljs-operator">=</span> scanResult.getClassesWithAnnotation(fullPathAnnotation);<br>        <span class="hljs-comment">// //获取注解参数列表</span><br>        List&lt;AnnotationParameterValueList&gt; annoParamList = classesWithAnnotation.stream().<br>                flatMap(clazz -&gt;<br>                        clazz.getAnnotationInfo().<br>                                stream().<br>                                map(AnnotationInfo::getParameterValues)<br>                ).collect(Collectors.toList());<br>        scanResult.close();<br>        <span class="hljs-keyword">return</span> annoParamList;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 枚举</title>
    <link href="/2022/04/08/Java%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2022/04/08/Java%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a>Java 枚举</h1><p>枚举在jdk1.5被加入。枚举是一个被命名的整型常数的<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>，用于声明一组带标识符的常数.</p><p>枚举的特点：</p><ul><li><p><strong>枚举可以实现接口，但不能继承接口，也不能被继承。</strong></p></li><li><p><strong>枚举类是final的，所以不能继承。</strong></p></li><li><p><strong>枚举类的构造方法私有的；枚举成员均是static、final，public</strong></p></li><li><p><strong>枚举成员是枚举类的实例</strong></p></li></ul><h2 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h2><p>enum-modifiers:访问权限修饰符  默认即为public. enum-base为枚举基本类型，默认为int</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span>-modifiers <span class="hljs-keyword">enum</span> <span class="hljs-title class_">enumname</span>:<span class="hljs-keyword">enum</span>-base&#123;<br>    <span class="hljs-keyword">enum</span>-body,<br>&#125;<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    Red,Green,Blue; <span class="hljs-comment">//枚举成员 !!!不是Color的属性而是其对象</span><br>&#125;<br><br><span class="hljs-comment">//枚举中声明的属性要通过构造器填充到枚举成员中</span><br><span class="hljs-comment">//枚举中方法枚举成员可以调用</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;<br>    Male(<span class="hljs-string">&quot;男&quot;</span>,<span class="hljs-number">1</span>),Female（<span class="hljs-string">&quot;女&quot;</span>,<span class="hljs-number">0</span>）; <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Gender</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> value)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=name;<br>        <span class="hljs-built_in">this</span>.value=value;<br>    &#125;<br>    <span class="hljs-comment">//Getter,Setter...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举类及方法"><a href="#枚举类及方法" class="headerlink" title="枚举类及方法"></a>枚举类及方法</h2><p>Java 中的每一个枚举都默认继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可</p><h3 id="1-常用方法："><a href="#1-常用方法：" class="headerlink" title="1.常用方法："></a>1.常用方法：</h3><p>除了toString方法，都是final修饰的方法，因此都不能重写。</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>values()</td><td>以数组形式返回枚举类型的所有成员</td></tr><tr><td>valueOf()</td><td>将普通字符串转换为枚举实例</td></tr><tr><td>compareTo()</td><td>比较两个枚举成员在定义时的顺序</td></tr><tr><td>ordinal()</td><td>获取枚举成员的索引位置</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEnum</span> &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span> &#123;<br>        male, female;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Gender.values().length; i++) &#123;<br>            Gender.valueOf(<span class="hljs-string">&quot;male&quot;</span>).compareTo(Gender.values()[i])<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-自定义属性和方法"><a href="#2-自定义属性和方法" class="headerlink" title="2.自定义属性和方法"></a>2.自定义属性和方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PizzaStatus</span> &#123;<br>        ORDERED (<span class="hljs-number">5</span>)&#123;<br>            <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//支持重写</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOrdered</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;,<br>        READY (<span class="hljs-number">2</span>),<br>        DELIVERED (<span class="hljs-number">0</span>);<br> <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> timeToDelivery;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOrdered</span><span class="hljs-params">()</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>       <span class="hljs-comment">//Getter,Setter</span><br></code></pre></td></tr></table></figure><h2 id="枚举实现接口"><a href="#枚举实现接口" class="headerlink" title="枚举实现接口"></a>枚举实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">describe</span><span class="hljs-params">()</span>;<br>&#125;<br><br> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EnumImplement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span> &#123;<br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>) &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">describe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;春江水阿暖鸭先知&quot;</span>);<br>        &#125;<br>    &#125;,<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> String season;<br><br>    EnumImplement(String season) &#123;<br>        <span class="hljs-built_in">this</span>.season = season;<br>    &#125;<br>     <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">describe</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;打印季节&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举经典用法"><a href="#枚举经典用法" class="headerlink" title="枚举经典用法"></a>枚举经典用法</h2><p>​      通过枚举实现单例被称为最完美的单例模式实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">AppleFactory</span>&#123;<br>   Instance;<br>   <span class="hljs-keyword">public</span> AppleFactory  <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-keyword">return</span> Instance;<br>   &#125;<br>&#125;<br><span class="hljs-comment">//usage:</span><br>AppleFactory.getInstance();<br></code></pre></td></tr></table></figure><p>​     通过枚举实现策略模式  （策略模式即由不同类来实现同一个接口 来降低对具体类的依赖度，增加新的业务逻辑时只需编写新的接口实现类即可.）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PayMode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span>&#123;<br>    WeChatPay,<br>    ALiPay,<br>    CardPay&#123;          <span class="hljs-comment">//增加新的支付方式，只需增加一个枚举成员即可</span><br>        <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>&#123;<br>           System.out.println(<span class="hljs-string">&quot;使用card支付&quot;</span>)；<br>       &#125;;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端调用-押金支付选择支付手段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayClient</span> &#123;<br>    String payName=<span class="hljs-string">&quot;card&quot;</span><br>    PayMode.valueOf(payName)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 反射</title>
    <link href="/2022/03/18/Java%20%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/03/18/Java%20%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h1><h2 id="反射定义"><a href="#反射定义" class="headerlink" title="反射定义"></a>反射定义</h2><p>​      反射指在java程序在Runntime仍然可以加载Java类（动态性的体现），并将其创建为对象，以供使用。</p><p>​      反射底层使用的仍是构造器创建对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">clazz.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;      <span class="hljs-comment">//默认选用无参构造器</span><br>clazz.get<span class="hljs-constructor">Constructor(<span class="hljs-params">args</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span> <span class="hljs-comment">//定制化选择构造器</span><br></code></pre></td></tr></table></figure><p>即在运行状态中：</p><blockquote><p><strong>1、对于任意一个类，都能够知道这个类的所有属性和方法;</strong></p><p><strong>2、对于任意一个对象，都能够调用它的任意一个属性和方法。</strong></p></blockquote><p>提及反射，就离不开 Class<T> 类，Class类是一个可以阐述所有类的类.</p><p>java创建对象的流程</p><p><img src="http://oss.randallstevens.top/reflection.png" alt="reflection"></p><h2 id="反射优缺点"><a href="#反射优缺点" class="headerlink" title="反射优缺点"></a>反射优缺点</h2><p>​           优： 反射机制被称为框架的设计灵魂。 反射提高了程序的灵活性，可以很方便的实现各种设计模式，减少代码的更改。如spring ioc容器，mybatis等， 通过修改配置文件来达到改变程序，提高程序灵活性 （OCP原则） .</p><p>​          缺：通过反射创建对象效率较低.</p><h2 id="反射的运用"><a href="#反射的运用" class="headerlink" title="反射的运用"></a>反射的运用</h2><p>​       获取字节码对象的方式：</p><blockquote><ul><li>Class.forName(“classPath”)</li><li>类名.class</li><li>对象名.getClass( )        </li></ul></blockquote><p>​     获取类的方法信息:</p><blockquote><p>方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p><ul><li>public Method[] getDeclaredMethods() throws SecurityException </li></ul><p>方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。</p><ul><li>public Method[] getMethods() throws SecurityException</li></ul><p> 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</p><ul><li>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</li></ul><p>获取构造器  通过Class类的getConstructor方法得到Constructor类的一个实例</p><ul><li>public T newInstance(Object … initargs)     //Constructor类有一个newInstance方法可以创建一个对象实例</li></ul></blockquote><p>  获取类的字段信息：</p><blockquote><ul><li><code>getFiled</code>：访问公有的成员变量</li><li><code>getDeclaredField</code>：所有已声明的成员变量，但不能得到其父类的成员变量</li></ul><p>与获取方法信息类似</p></blockquote><p>方法的调用：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object obj, Object... args)</span>     <span class="hljs-comment">//方法原型</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        Class&lt;Add&gt; addClazz = Add.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> addClazz.getMethod(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> add.invoke(addClazz.newInstance(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        System.out.println(result);  <span class="hljs-comment">//输出3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testArray</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        Class&lt;?&gt; cls = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> Array.newInstance(cls,<span class="hljs-number">25</span>); <span class="hljs-comment">//指定元素类型，长度</span><br>        Array.set(array,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>        Array.set(array,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;2&quot;</span>);<br>        Array.set(array,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(Array.get(array,<span class="hljs-number">3</span>));<br>    &#125;<br></code></pre></td></tr></table></figure></blockquote><p>​     </p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 泛型</title>
    <link href="/2022/03/15/Java%20%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/03/15/Java%20%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h1><p><strong>泛型是指将数据类型参数化，在使用时指定具体的类型，使得编译器可以进行安全检查，保证类型安全</strong></p><p>tip: 泛型不支持基本数据类型.</p><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><blockquote><p>在实例化类时指定具体类型</p><p>定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java">class 类名 &lt;T，E，...&gt; &#123;<br>   <span class="hljs-keyword">private</span> T  变量名;<br>   <span class="hljs-keyword">public</span>  T  <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;&#125;;   <span class="hljs-comment">//此处不为泛型方法!!!</span><br>   <span class="hljs-keyword">public</span>  String  <span class="hljs-title function_">show</span><span class="hljs-params">(T type)</span>&#123;&#125;;  <br>   ....<br>&#125;<br><br><span class="hljs-comment">//常用泛型标识符：T,E,K,V   Class&lt;T&gt;类</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &lt;T&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T type;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGeneric</span><span class="hljs-params">(T type)</span>&#123;<br>        <span class="hljs-built_in">this</span>.type=type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T  <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.type);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>.type;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         Test&lt;String&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>         test.setGeneric(<span class="hljs-string">&quot;hello&quot;</span>);<br>         test.show();<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>特殊的泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//泛型字节码类  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class</span>&lt;T&gt;&#123;&#125;   <span class="hljs-comment">//class是一个可以诠释所有类的类，传入是&lt;Test.class&gt;</span><br><br><span class="hljs-comment">//泛型类派生子类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildGereric</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneriic</span>&lt;T&gt;     <span class="hljs-comment">//父子类均为泛型类，则父子类的泛型类型必须相同</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildGereric</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ParentGeneriic</span>&lt;String&gt;   <span class="hljs-comment">//子类不是泛型类，则父类泛型必须明确</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><blockquote><p>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 接口名称 &lt;T，E，…&gt; &#123;<br>T <span class="hljs-title function_">method1</span><span class="hljs-params">(E elem)</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//实现类为泛型类，则泛型类的泛型类型必须包括接口中所有的泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T,E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;<br><span class="hljs-comment">//实现类不为泛型类，则接口必须明确泛型类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;<br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><blockquote><p>调用方法时指定泛型的具体类型</p><p>定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T，E, ...&gt; T 方法名(E... elem) &#123;&#125;   <span class="hljs-comment">//泛型类中泛型与泛型方法中泛型独立，即使名字相同</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//普通泛型方法</span><br><span class="hljs-keyword">public</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(E... e)</span>&#123; <span class="hljs-comment">//传入可变参数  e会作为一个数组</span><br><span class="hljs-keyword">for</span> (E e1 : e) &#123;<br>System.out.println(e);<br>&#125;<br>&#125;<br><span class="hljs-comment">//静态泛型方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(E... e)</span>&#123;&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><blockquote><p><strong>数据类型参数化，参数实参化</strong></p><ul><li>泛型类型通配符使用”?”代指类型实参**</li></ul><ul><li><T> 类型形参（或直接叫泛型）；<String>类型实参（泛型的类型）</li></ul><ul><li>类型通配符是类型实参，而不是类型形参   </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">A</span>&lt;T&gt;&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span>  <span class="hljs-title class_">UseA</span>&#123;<br>  <br>    <span class="hljs-keyword">public</span> staic <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(A&lt;?&gt; a)</span>&#123;    <span class="hljs-comment">//此处的参数已经使用实例化a,必须指定泛型类型实参，通过？代指所有类型实参</span><br>      a.method();<br>   &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args )</span>&#123;<br>        A&lt;String&gt;  a1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;<br>        A&lt;Interger&gt; a2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;<br>        UseA.use(a1);<br>        UseA.use(a2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限"></a>类型通配符上限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 类/接口&lt;? extends T&gt;     指定实参类型上限</span><br><span class="hljs-comment">// 要求该泛型的类型，只能是T或其子类(上限是T)</span><br>class &lt;？<span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;   <br><span class="hljs-comment">//上述例子</span><br>  <span class="hljs-keyword">public</span> staic <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(A&lt;？extends Number&gt;  a)</span>&#123;    <br>      a.method();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限"></a>类型通配符下限</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类/接口&lt;? super T&gt;</span><br><span class="hljs-comment">//要求该泛型的类型，只能是T或其父类(下限是T)</span><br>class &lt;？ <span class="hljs-built_in">super</span> son&gt;   <br><span class="hljs-comment">//可传入的参数（father）/(son)</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><blockquote><p><strong>即泛型在编译期间会被编译器擦除，字节码中是没有泛型的.</strong></p><p><strong>擦除规则</strong>：</p><ul><li>若泛型类型没有指定具体类型，用Object作为原始类型；</li><li>若有限定类型&lt; T exnteds XClass &gt;，使用XClass作为原始类型；</li><li>若有多个限定&lt; T exnteds XClass1 &amp; XClass2 &gt;，使用第一个边界类型XClass1作为原始类型.</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven</title>
    <link href="/2022/03/15/maven/"/>
    <url>/2022/03/15/maven/</url>
    
    <content type="html"><![CDATA[<h1 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>Maven是一个专业化的项目管理工具.</strong> </p><ul><li><p>它将项目的开发和管理过程抽象成一个项目对象模型（POM）进行管理</p></li><li><p> 通过pom.xml来进行项目的配置和管理</p></li></ul><p><strong>Maven的作用</strong></p><ul><li>项目构建:  提供标准的，跨平台的自动化项目构建方式</li><li>依赖管理:  方便快捷管理项目的依赖资源（jar包），解决版本冲突</li><li>统一开发结构: 制定了统一标准的项目结构</li></ul><p><strong>Maven的下载安装</strong></p><ol><li>   Apache官网下载</li><li>  解压即可（maven依赖于java 环境）</li><li> 配置环境变量</li></ol><h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1.Basic"></a>1.Basic</h2><blockquote><p><strong>仓库</strong>：存放jar包资源的地方.</p><p>​          分类：1. 本地仓库      2.远程仓库：私服，中心仓库</p><p><strong>坐标</strong>：唯一的对依赖进行标识</p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml">&lt; <span class="hljs-comment">&lt;!-- 示例 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.hbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hbase-examples<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>镜像,仓库配置</strong>：maven默认的中央仓库在国外，下载速度慢，故需要配置镜像来加速下载.</p><p>​          进入maven安装目录下的conf/setting.xml </p><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 阿里云mirrors  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">&gt;&gt;<span class="hljs-comment">&lt;!--  本地仓库配置 --&gt;</span>  <br>&gt;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\JavaEE\maven repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p><strong>依赖管理</strong></p><ul><li>依赖具有传递性</li><li>依赖冲突解决：不同层，层级越深，优先级高；同层先声明的优先级高</li><li>可选依赖</li></ul><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <span class="hljs-comment">&lt;!--  依赖对外隐藏 --&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><ul><li>依赖排除</li></ul><blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.struts<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>struts2-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;struts.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>      <span class="hljs-comment">&lt;!--  不下载使用该依赖中的部分 --&gt;</span>      <br>               <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>  <br>                   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>asm<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>                   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>asm-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>           <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>  <br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure></blockquote></blockquote><p>​    </p><h2 id="2-Feature"><a href="#2-Feature" class="headerlink" title="2.Feature"></a><strong>2.Feature</strong></h2><blockquote><p><strong>生命周期</strong>：对于项目的构建过程，Maven 抽象出了一个适合于所有项目的标准，并将它们统一规范。称之为生命周期.</p><blockquote><ul><li><p>项目的构建具体步骤包括清理、初始化、编译、测试、打包、集成测试、验证、部署和生成站点。这些步骤几乎适合所有的项目，即所有项目的管理构建过程都可以对应到这个生命周期上来.</p></li><li><p>Maven 的生命周期只是制定了标准，具体实现由maven的插件来完成的.</p></li><li><p><strong>生命周期的阶段</strong>: Maven拥有三套独立的生命周期，它们分别是 clean、default 和 site。</p></li></ul></blockquote><p>1.clean 生命周期的目的是清理项目；</p><blockquote><blockquote><table><thead><tr><th><strong>阶段</strong></th><th>说明</th></tr></thead><tbody><tr><td>pre-clean</td><td>执行清理前需要完成的工作</td></tr><tr><td>clean</td><td>清理构建生成的文件</td></tr><tr><td>post-clean</td><td>执行清理后需要完成的工作</td></tr></tbody></table></blockquote></blockquote><p> 2.default 生命周期的目的是构建项目；default 是生命周期的核心周期。步骤比较多，下表只列出了核心的一段.其他部分可查看.  <a href="http://c.biancheng.net/view/4899.html">maven生命周期</a></p><blockquote><blockquote><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>compile</td><td>编译项目的源代码</td></tr><tr><td>install</td><td>将包安装至本地仓库，以让其它项目依赖</td></tr><tr><td>deploy</td><td>将最终的包复制到远程的仓库，以让其它开发人员与项目共享</td></tr><tr><td>test</td><td>使用合适的单元测试框架运行测试。</td></tr><tr><td>test-compile</td><td>编译测试源代码</td></tr><tr><td>package</td><td>接收编译好的代码，打包成可发布的格式，如 JAR</td></tr></tbody></table></blockquote></blockquote><p>3.site 生命周期的目的是建立项目站点。</p><blockquote><blockquote><table><thead><tr><th>阶段</th><th>说明</th></tr></thead><tbody><tr><td>pre-site</td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td>site</td><td>生成项目的站点文档</td></tr><tr><td>post-site</td><td>执行生成站点后需要收尾的工作</td></tr><tr><td>site-deploy</td><td>将生成的站点发布到服务器上</td></tr></tbody></table></blockquote></blockquote><p><strong>模块聚合与继承</strong></p><blockquote><p><strong>聚合</strong>：新建一个maven项目；  在此项目基础上新建maven模块,在父项目的pom.xml中通过<moudle>来指定子模块<br><strong>继承</strong>：子模块通过<parent> 继承父模块，且模块间的依赖也会继承，继承会将一切继承包括插件，设置等全部<br><strong>所要进行聚合的父项目和所要被继承的父项目可以不是同一个（一般设置为同一个）！！！！！！</strong>                                             父项目一般只用来模块设计（聚合），一般删除src文件夹；打包方式为pom。<br>聚合中父项目是有感知，子模块无感知，即子模块认为自己是一个独立的项目<br>继承中被继承的模块是无感知的，主动继承的是有感知的<br><strong>项目结构示例</strong>：<br><img src="http://oss.randallstevens.top/maven_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"><br><strong>依赖关系示例</strong>：<br>     <strong>父项目依赖druid,   project_Dao依赖spring-beans, 而project_Service依赖于模块Dao,</strong><br><img src="http://oss.randallstevens.top/maven_%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt=" ">      </p></blockquote><p>​    </p><p><strong>POM属性</strong>：</p><blockquote><p>Maven中支持属性类型<br>​     自定义属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <span class="hljs-comment">&lt;!--自定义属性  --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.1.9.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span> <br> <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <span class="hljs-comment">&lt;!--调用属性  --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br></code></pre></td></tr></table></figure><p>​      内置属性：如 $<version>该项目版本变量<br>​                     $&lt;base.dir&gt;    该项目根路径变量 等<br>​      setting属性：用于动态获取maven的setting.xml中信息如 ${settings.localRepository}<br>​      系统属性：读取java相关系统属性属性和系统环境变量属性. 如​{env.JAVA_HOME}，也可通过 maven命令查看：mvn  help:system</p></blockquote><p><strong>其他特性</strong></p><p>​     <strong>资源配置，资源过滤，私服搭建等</strong></p></blockquote><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><h3 id="3-1-maven打包"><a href="#3-1-maven打包" class="headerlink" title="3.1   maven打包"></a>3.1   maven打包</h3><blockquote><p>​      使用maven默认打包不会包含依赖，且无法通过   java  jar  -xxx.jar 直接运行 </p><p>要想项目打包后可直接运行需满足两个条件</p><ol><li><p>包含依赖</p></li><li><p>在jar包中的META-INF/MANIFEST.MF中指定Main-Class</p></li></ol><p>打包可直接运行jar包的方式</p><ol><li> 使用maven-jar-plugin和maven-dependency-plugin插件打包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  //负责指定主类<br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-jar-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">archive</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">addClasspath</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addClasspath</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">classpathPrefix</span>&gt;</span>lib/<span class="hljs-tag">&lt;/<span class="hljs-name">classpathPrefix</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.xxg.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">archive</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   //负责打包依赖<br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><ol start="2"><li> maven-shade-plugin</li></ol><p>   在target目录下会生成两个jar包，original-xxx.jar，xxx-jar-with-dependencies.jar。注意在spring项目使用时还需额外的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>  <br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>  <br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  <br>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span>  <br>                               <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span>                                               <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span>  <br>                                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.xxg.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span>  <br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span>  <br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span>  <br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  <br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>3.springboot 项目直接使用springboot提供的spring-boot-maven-plugin即可</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称/非对称加密</title>
    <link href="/2022/03/13/%E5%AF%B9%E7%A7%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <url>/2022/03/13/%E5%AF%B9%E7%A7%B0%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="对称-非对称加密方式"><a href="#对称-非对称加密方式" class="headerlink" title="对称/非对称加密方式"></a>对称/非对称加密方式</h1><h2 id="1-对称加密"><a href="#1-对称加密" class="headerlink" title="1. 对称加密"></a>1. 对称加密</h2><blockquote><p>​      即加密密钥和解密密钥相同的密钥体制，加密算法和解密算法公开，也是最常见的一种.对称加密算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p><p>​     常见对称加密算法：DES,3DES</p><p>​    对称加密的一大缺点是密钥的管理与分配，如何把密钥发送到需要解密的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人,如https的实现.</p></blockquote><h2 id="2-非对称加密"><a href="#2-非对称加密" class="headerlink" title="2.非对称加密"></a>2.非对称加密</h2><blockquote><p>加密密钥（公钥）和解密密钥（私钥）不同，且不能根据一个密钥得到另一个密钥。加密算法和解密算法公开.</p><p>非对称加密效率较低，但可以很方便的进行身份鉴别，数字签名。</p><p>常见对称加密算法：RSA,DSA </p><p><strong>公钥用来加密，验证签名；私钥用来解密，签名</strong>。</p><p>​       数字签名：CA机构以签名的形式对公开公钥的用户颁发一个数字证书的过程</p><p>​             特点：签名使得证书不能被修改</p><p>​                   <img src="http://oss.randallstevens.top/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p></blockquote><h2 id="3-实际应用"><a href="#3-实际应用" class="headerlink" title="3.实际应用"></a>3.实际应用</h2><h3 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h3><p>​       SSH的用户认证方式有两种，第一种是账户密码登录，即你需要连接的远程服务器某一个用户与密码，比较常用，也比较简单。第二种是公钥验证授权登录，适合批量化管理集群。</p><p>​         1. <strong>密码验证登录</strong></p><p>​             用户在客户端ssh远程服务器，远程服务器将自己的公用密钥下发至客户端的~/.ssh/known_hosts，客户端将使用该公开密钥来加密数据，远程服务器使用自己的私有密钥来解密数据，从而实现加密访问过程。</p><img src="http://oss.randallstevens.top/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_ssh1.jpg" style="zoom:60%;"/><p>​         2.  <strong>免密登录</strong></p><p>​              本质：能实现免密登录是因为服务器端已经验证过客户端的合法身份，且将验证的记录保存在了本地。故无需再验证.  </p><p>​              具体流程： 客户端携带着公钥向服务器发出请求，服务器收到请求后，在 ~/.ssh/authorized_keys信任文件里比对该公钥是否存在，如果对比成功，远端服务器则使用该公钥加密一个随机字符串（challenge）发送给客户端。客户端接收后，将随机字符串（challenge）用自己的私钥进行解密，之后将解密后的结果传给服务器，服务器对比传来的字符串是否一致，一致则建立连接。</p><img src="http://oss.randallstevens.top/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_ssh2.jpg" style="zoom:60%;" /><h3 id="https的实现"><a href="#https的实现" class="headerlink" title="https的实现"></a>https的实现</h3><p>​    概括：<strong>通过非对称加密的方式来约定一个对称加密密钥，同时采用hash来保证报文完整性</strong></p><p>​     HTTPS同时采用了对称加密算法，非对称加密算法，hash算法。 一般使用的加密与HASH算法如下：</p><p>​               非对称加密算法：RSA，DSA/DSS<br>​               对称加密算法：AES，RC4，3DES<br>​               HASH算法：MD5，SHA1，SHA256<br>​     <img src="http://oss.randallstevens.top/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_https.png"></p><p>   1）浏览器将自己支持的一套加密规则发送给网站。<br>   2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。并告知浏览器所选取的算法.<br> 3）浏览器获得网站证书之后浏览器要做以下工作：<br>      a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>      b) 如果证书受信任，或用户接受了不受信的证书，浏览器用对称加密生成一个密钥，将所用的对称加密算法和生成的密钥用证书中提供的公钥加密。<br>      c) 使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。<br> 4）网站接收浏览器发来的数据之后要做以下的操作：<br>      a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>      b) 使用密码加密一段握手消息，发送给浏览器。<br> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。<br>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p><p>证书示例：<br>    <img src="http://oss.randallstevens.top/%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3_%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>对称/非对称加密</tag>
      
      <tag>SSH免密原理</tag>
      
      <tag>https加密原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用</title>
    <link href="/2022/03/08/Git%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/03/08/Git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>托管中心</strong><code>维护远程库</code></p><ul><li><strong>内网：可以自己搭建一个GitLab服务器</strong></li><li><strong>外网：可以使用码云、Github</strong></li></ul><p><strong>版本控制工具</strong></p><ul><li><strong>集中式</strong>：CSV ,<strong>SVN</strong>,VSS</li><li><strong>分布式</strong>：<strong>Git</strong>，Darcs,…</li></ul><h2 id="Git命令行操作"><a href="#Git命令行操作" class="headerlink" title="Git命令行操作"></a>Git命令行操作</h2><h3 id="1-1本地库初始化"><a href="#1-1本地库初始化" class="headerlink" title="1.1本地库初始化"></a>1.1本地库初始化</h3><p><code>进入文件夹</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br>注意：生成的 .git 目录中存放的是本地库相关文件，不要删除<br></code></pre></td></tr></table></figure><h3 id="1-2设置签名"><a href="#1-2设置签名" class="headerlink" title="1.2设置签名"></a>1.2设置签名</h3><ul><li><p>项目(仓库)级别<code>仅在当前本地库有效</code></p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git config <span class="hljs-keyword">user</span>.name tom  <span class="hljs-comment">#设置用户名tom</span><br>git config <span class="hljs-keyword">user</span>.email liu@qq.com <span class="hljs-comment">#设置用户邮箱</span><br></code></pre></td></tr></table></figure></li><li><p>系统用户级别<code>仅在当前登录的操作系统用户有效</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.name tom</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global user.email liu@qq.com</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>仅仅加了一个 <code>--global</code></p><p>优先级别：<code>项目级别</code>  &gt;  <code>系统级别</code></p><p>信息保存位置：<code>~/.gitconfig 文件</code>   </p></blockquote><h3 id="1-3基本操作"><a href="#1-3基本操作" class="headerlink" title="1.3基本操作"></a>1.3基本操作</h3><h4 id="1-3-1-状态查看"><a href="#1-3-1-状态查看" class="headerlink" title="1.3.1 状态查看"></a>1.3.1 状态查看</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> status   <span class="hljs-comment">#查看工作区、暂存区状态</span><br></code></pre></td></tr></table></figure><h4 id="1-3-2-添加"><a href="#1-3-2-添加" class="headerlink" title="1.3.2 添加"></a>1.3.2 添加</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> fileName  <span class="hljs-meta">#指定文件</span><br>git <span class="hljs-keyword">add</span> . <span class="hljs-meta">#所有</span><br>说明：将工作区的文件添加到暂存区<br></code></pre></td></tr></table></figure><h4 id="1-3-3-提交"><a href="#1-3-3-提交" class="headerlink" title="1.3.3 提交"></a>1.3.3 提交</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&#x27;commit message&#x27;</span> fileName<br>说明：将暂存区内容提交到本地库<br></code></pre></td></tr></table></figure><h4 id="1-3-4-查看历史记录"><a href="#1-3-4-查看历史记录" class="headerlink" title="1.3.4 查看历史记录"></a>1.3.4 查看历史记录</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span> <br>git reflog  <span class="hljs-meta">#常用</span><br>git <span class="hljs-built_in">log</span> --greph <span class="hljs-meta">#图形显示,更直观</span><br>git <span class="hljs-built_in">log</span> --pretty=oneline <span class="hljs-meta">#漂亮一行显示</span><br>git <span class="hljs-built_in">log</span> --oneline <span class="hljs-meta">#简洁显示</span><br>说明：HEAD@&#123;移动到当前版本需要多少步&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-5-前进后退"><a href="#1-3-5-前进后退" class="headerlink" title="1.3.5 前进后退"></a>1.3.5 前进后退</h4><ul><li><p>基于索引值<code>推荐</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 指针位置</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard a6ace91 #回到这个状态</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <strong>^</strong> 符号<code>只能后退</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^^</span><br>注意：几个 ^ 表示后退几步<br></code></pre></td></tr></table></figure></li><li><p>使用 <strong>~</strong> 符号<code>只能后退</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~n</span><br>例子：git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD~3</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="1-3-6-reset的三个参数比较"><a href="#1-3-6-reset的三个参数比较" class="headerlink" title="1.3.6 reset的三个参数比较"></a>1.3.6 reset的三个参数比较</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">soft</span><span class="hljs-punctuation">: </span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">仅本地库移动HEAD 指针</span><br><span class="hljs-attribute">mixed</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">在本地库移动HEAD指针</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置暂存区</span><br><span class="hljs-attribute">hard</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">在本地库移动HEAD指针</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置暂存区</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">重置工作区</span><br></code></pre></td></tr></table></figure><h4 id="1-3-7-删除文件并找回"><a href="#1-3-7-删除文件并找回" class="headerlink" title="1.3.7　删除文件并找回"></a>1.3.7　删除文件并找回</h4><ul><li><strong>相当于建立一个快照，虽然删除了，但只要添加到暂存区，就能找回</strong></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 指针位置</span><br></code></pre></td></tr></table></figure><h4 id="1-3-8-文件差异比较"><a href="#1-3-8-文件差异比较" class="headerlink" title="1.3.8 文件差异比较"></a>1.3.8 文件差异比较</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">diff </span>文件名<br>git <span class="hljs-keyword">diff </span>哈希值 文件名  <span class="hljs-comment">#和历史中的一个版本比较</span><br>git <span class="hljs-keyword">diff </span> <span class="hljs-comment">#不带文件名，则比较多个文件</span><br></code></pre></td></tr></table></figure><h3 id="2-2-分支管理"><a href="#2-2-分支管理" class="headerlink" title="2.2 分支管理"></a>2.2 分支管理</h3><p><code>hot_fix</code> <code>master</code> <code>feature_x</code> <code>feature_y</code></p><h4 id="2-2-1-什么是分支管理"><a href="#2-2-1-什么是分支管理" class="headerlink" title="2.2.1 什么是分支管理"></a>2.2.1 什么是分支管理</h4><ul><li>在版本控制中，使用推进多个任务</li></ul><h4 id="2-2-2-分支的好处"><a href="#2-2-2-分支的好处" class="headerlink" title="2.2.2 分支的好处"></a>2.2.2 分支的好处</h4><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>某一分支开发失败，不会对其它分支有任何影响</li></ul><h4 id="2-2-3-分支操作"><a href="#2-2-3-分支操作" class="headerlink" title="2.2.3 分支操作"></a>2.2.3 分支操作</h4><ul><li>创建分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>分支名<br></code></pre></td></tr></table></figure><ul><li>查看分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch</span><br><span class="hljs-keyword"></span>git <span class="hljs-keyword">branch </span>-v <br></code></pre></td></tr></table></figure><ul><li>切换分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git checkout 分支名<br>git checkout -<span class="hljs-keyword">b </span>分支名   <span class="hljs-comment">#创建分支并直接切换到该分支</span><br></code></pre></td></tr></table></figure><ul><li>合并分支<code>相当于把修改了的文件拉过来</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git merge xxx<br>注意：合并分支的时候要明确谁谁合并<br>我在a分支里面修改了。要合并到<span class="hljs-literal">master</span>，就先切换到<span class="hljs-literal">master</span>，然后合并b<br></code></pre></td></tr></table></figure><ul><li>删除分支</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span>-d 分支名<br></code></pre></td></tr></table></figure><h4 id="2-2-4-解决冲突"><a href="#2-2-4-解决冲突" class="headerlink" title="2.2.4 解决冲突"></a>2.2.4 解决冲突</h4><ul><li>冲突的表现</li><li>冲突的解决<ul><li>第一步：编辑，删除特殊标记<code>&lt;&lt;&lt;</code> <code>===</code></li><li>第二步：修改到满意位置，保存退出</li><li>第三步：添加到缓存区  <code>git  add 文件名</code></li><li>第四步：提交到本地库<code>git commit -m &#39;日志信息&#39; </code>  <code>注意：后面一定不能带文件名</code></li></ul></li></ul><h2 id="Git-结合Github"><a href="#Git-结合Github" class="headerlink" title="Git 结合Github"></a>Git 结合Github</h2><p><code>别分手</code>  <code>别名 分支名</code></p><h4 id="1-1-创建远程库地址别名"><a href="#1-1-创建远程库地址别名" class="headerlink" title="1.1 创建远程库地址别名"></a>1.1 创建远程库地址别名</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git remote -v  <span class="hljs-meta">#查看 （远程主机名）</span><br>git remote <span class="hljs-keyword">add</span> 远程主机名 远程地址 <br>例子：git remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//xx</span><br></code></pre></td></tr></table></figure><h4 id="1-2-推送"><a href="#1-2-推送" class="headerlink" title="1.2 推送"></a>1.2 推送</h4><p><code>开发修改完把本地库的文件推送到远程仓库</code> <code>前提是提交到了本地库才可以推送</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">push</span> 别名 分支名<br>git <span class="hljs-keyword">push</span> -u 别名 分支名    <span class="hljs-meta">#-u指定默认主机</span><br>例子：git <span class="hljs-keyword">push</span> origin master <br></code></pre></td></tr></table></figure><h4 id="1-3-克隆"><a href="#1-3-克隆" class="headerlink" title="1.3 克隆"></a>1.3 克隆</h4><p><code>完整的把远程库克隆到本地</code>  <code>克隆下来后不要在主分支里面做开发</code> <code>clone进行一次，从无到有的过程，更新用pull</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span>  <span class="hljs-title">远程地址</span><br><span class="hljs-title">例子：git</span> <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://xx<br></code></pre></td></tr></table></figure><h4 id="1-4-拉取"><a href="#1-4-拉取" class="headerlink" title="1.4 拉取"></a>1.4 拉取</h4><p>  <code>本地存在clone下来的文件  就用pull更新</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">pull <span class="hljs-operator">=</span> <span class="hljs-keyword">fetch</span> <span class="hljs-operator">+</span> <span class="hljs-keyword">merge</span><br>git <span class="hljs-keyword">fetch</span> 别名 分支名<br>git <span class="hljs-keyword">merge</span> 别名 分支名<br>git pull 别名 分支名<br></code></pre></td></tr></table></figure><h4 id="1-5-解决冲突"><a href="#1-5-解决冲突" class="headerlink" title="1.5 解决冲突"></a>1.5 解决冲突</h4><p><code>注意：解决冲突后的提交是不能带文件名的</code></p><p><code>如果不是基于远程库最新版做的修改不能推送，必须先pull下来安装冲突办法解决</code></p><h4 id="1-6-rebase"><a href="#1-6-rebase" class="headerlink" title="1.6 rebase"></a>1.6 rebase</h4><p><code>提交记录简洁不分叉</code>  <code>没学懂，感觉有点鸡肋</code> <code>混眼熟</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">git rebase -<span class="hljs-selector-tag">i</span> 索引号<br>git rebase -<span class="hljs-selector-tag">i</span> HEAD~<span class="hljs-number">3</span>  #合并最近三条记录<br>说明：在vim编辑里面改成s<br></code></pre></td></tr></table></figure><h4 id="1-7-beyond-compare"><a href="#1-7-beyond-compare" class="headerlink" title="1.7 beyond compare"></a>1.7 beyond compare</h4><p><code>用软件解决冲突</code> </p> <figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-number">1.</span>安装 ：<br>beyond compare <br><span class="hljs-number">2.</span>配置：<br>    git config --<span class="hljs-keyword">local</span> merge.tool bc3  <span class="hljs-meta">#合并名称</span><br>    git config --<span class="hljs-keyword">local</span> mergetool.path <span class="hljs-string">&#x27;/usr/local/bin/bcomp&#x27;</span> <span class="hljs-meta">#软件路径</span><br>    git config --<span class="hljs-keyword">local</span> mergetool.keepBackup <span class="hljs-literal">false</span>  <span class="hljs-meta">#False不用保存备份</span><br><span class="hljs-number">3.</span>应用：<br>git mergetool<br>说明：--<span class="hljs-keyword">local</span>指只在当前操作系统有效<br></code></pre></td></tr></table></figure><h4 id="1-8-跨团队合作"><a href="#1-8-跨团队合作" class="headerlink" title="1.8 跨团队合作"></a>1.8 跨团队合作</h4><p><code>代码review之后合并</code></p><ul><li><p><strong>适用于个人</strong></p><p><strong>邀请成员</strong>:<code>Settings</code> –&gt; <code>Collaborators</code> –&gt;<code>填写用户名</code> –&gt;<code>打开链接接受邀请</code></p></li><li><p><strong>企业</strong>   <code>创建一个组织</code> <code>方便管理</code></p></li><li><p><strong>review</strong></p><p>  <code>组织做review</code>  <code>通过Pull request</code></p></li><li><p><strong>给开源社区共享代码</strong></p><p>  <code>点击别人仓库的fork 到自己的仓库</code>   – &gt; <code>然后clone下来 修改后推送到远程库</code>  –&gt; <code>点击Pull Request请求</code> –&gt; <code>Create pull request发消息</code></p></li></ul><h4 id="1-9-Tag标签"><a href="#1-9-Tag标签" class="headerlink" title="1.9 Tag标签"></a>1.9 Tag标签</h4><p><code>为了清晰的版本管理，公司一般不会直接使用commit提交</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> v1.<span class="hljs-number">0</span> -m &#x27;版本介绍&#x27;   <span class="hljs-comment">#创建本地tag信息</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> v1.<span class="hljs-number">0</span>    <span class="hljs-comment">#删除tag</span><br>git push origin --tags   <span class="hljs-comment">#将本地tag信息推送到远程库</span><br>git pull origin --tags    <span class="hljs-comment">#拉取到本地</span><br><br>git checkout v.<span class="hljs-number">10</span>    <span class="hljs-comment">#切换tag</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> v0.<span class="hljs-number">1</span> 地址   <span class="hljs-comment">#指定tag下载代码</span><br></code></pre></td></tr></table></figure><h4 id="1-10-SSH-免密登录"><a href="#1-10-SSH-免密登录" class="headerlink" title="1.10 SSH 免密登录"></a>1.10 SSH 免密登录</h4><ul><li>输入:<code>ssh-keygen -t rsa -C GitHub邮箱地址</code>  </li><li>进入<code>.ssh</code>目录，复制<code>id_rsa.pub</code>文件内容</li><li>登录GitHub。<code>Settings</code>  –&gt; <code>SSH and GPG keys </code> –&gt; <code>New SSH Key    </code></li><li>回到git通过ssh地址创建。<code>git remote add 别名 SSH地址  </code></li></ul><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在项目开发过程中使用Git的方式<br></code></pre></td></tr></table></figure><h4 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h4><h5 id="1-2-1-集中式工作流"><a href="#1-2-1-集中式工作流" class="headerlink" title="1.2.1 集中式工作流"></a>1.2.1 集中式工作流</h5><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">像SVN一样，集中式工作流有一个中央仓库，所有的修改都提交到了<span class="hljs-literal">Master</span>分支上<br></code></pre></td></tr></table></figure><h5 id="1-2-2-GitFlow工作流"><a href="#1-2-2-GitFlow工作流" class="headerlink" title="1.2.2 GitFlow工作流 *"></a>1.2.2 GitFlow工作流 <code>*</code></h5><p>主干分支<code>master</code>  开发分支<code>develop</code>  修复分支<code>hotfix</code>   预发布分支<code>release</code>  功能分支<code>feature</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">GitFlow</span> 有独立的分支，让发布迭代过程更流畅。<br></code></pre></td></tr></table></figure><h5 id="1-2-3-Forking-工作流"><a href="#1-2-3-Forking-工作流" class="headerlink" title="1.2.3 Forking 工作流"></a>1.2.3 Forking 工作流</h5><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">在 GitFlow 基础上， 充分利用了 Git 的 Fork 和 pull <span class="hljs-built_in">request</span> 的功能以达到代码审核的目的。 <br>安全可靠地管理大团队的开发者<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DesignPriciple</title>
    <link href="/2022/02/18/DesignPriciple/"/>
    <url>/2022/02/18/DesignPriciple/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式7大原则（Java-版）"><a href="#设计模式7大原则（Java-版）" class="headerlink" title="设计模式7大原则（Java 版）"></a><strong>设计模式7大原则（Java 版）</strong></h1><h2 id="面向对象设计原则概述"><a href="#面向对象设计原则概述" class="headerlink" title="面向对象设计原则概述"></a>面向对象设计原则概述</h2><p><strong>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一</strong></p><p><strong>各大设计原则不是独立存在的，存在相互依赖，相互补充的关系，甚至有些原则只是某个原则的延伸，具体实现等.</strong></p><p><strong>使用设计模式的目的就是 尽可能低代价的实现代码功能的复用与扩充，提高代码的可维护性 ；达到高内聚低耦合</strong></p><h2 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1.单一职责原则 (SRP)"></a>1.单一职责原则 (SRP)</h2><p>​    <strong>Single Responsibility Principle</strong></p><h3 id="单一职责定义"><a href="#单一职责定义" class="headerlink" title="单一职责定义"></a>单一职责定义</h3><blockquote><p>一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因</p></blockquote><h3 id="单一职责实例"><a href="#单一职责实例" class="headerlink" title="单一职责实例"></a>单一职责实例</h3><p>​      有如下类登录、注册、支付宝押金支付、微信押金支付、套餐支付、整个结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用户功能模块</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">userController</span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 押金支付(阿里)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payAliDeposit</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 押金支付(微信)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payWXDeposit</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 套餐支付</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payPackage</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>​        如上很多功能都糅杂在一起，一个类做了很多事情，很臃肿，各个方法间无紧密联系. 所以我们可以对这个UserController进行拆解，与此同时我们应该分包，比如这个应该在xxx.xxx.userMoudule下面，可能支付相关的有公共的方法，登录抑或也有公共的方法，那边抽取成公共服务去调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span>()&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">registerController</span>()&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">depositPayController</span>()&#123;<br>    <span class="hljs-comment">// 支付宝支付</span><br>    <span class="hljs-comment">// 微信支付</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">packagePayController</span>()&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-开闭原则-OCP"><a href="#2-开闭原则-OCP" class="headerlink" title="2.开闭原则 (OCP)"></a>2.开闭原则 (OCP)</h2><p>​    <strong>Open Close Principle</strong></p><h3 id="开闭原则定义"><a href="#开闭原则定义" class="headerlink" title="开闭原则定义"></a>开闭原则定义</h3><blockquote><p>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p></blockquote><p>  软件实体包括</p><ul><li><p>项目中的模块</p></li><li><p>抽象和类</p></li><li><p>方法  </p><p><strong>使用开闭原则的好处</strong>：不影响原代码的运行，提高了可维护性，复用性</p></li></ul><p><strong>开闭原则使用方式</strong></p><p>​    <strong>抽象约束</strong></p><ul><li><p>通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；</p></li><li><p>参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；（针对抽象编程）</p></li><li><p>抽象层尽量保持稳定，一旦确定即不允许修改。</p></li></ul><p>​    <strong>元数据控制模块行为</strong><br>​      通过配置文件来操作数据，spring的控制反转(application.xml控制对象的创建)就是一个很典型的例子。<br>​      依赖注入是实现开闭原则的一种方式.</p><p>   <strong>约定优于配置</strong></p><p>   <strong>封装变化</strong></p><p>   <strong>将相同的变化封装到一个接口或者类中</strong></p><p>   <strong>将不同的变化封装到不同的类或者接口中（单一职责的体现）</strong></p><h3 id="开闭原则实例"><a href="#开闭原则实例" class="headerlink" title="开闭原则实例"></a>开闭原则实例</h3><p>  某租车系统有一个押金支付功能，支付方式有支付宝、阿里支付，后期可能还有银联支付、易支付等等，设计方案如下：</p><p><img src="http://oss.randallstevens.top/DesignPriciple_1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 客户端调用-押金支付选择支付手段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepositPay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String type)</span>&#123;<br>        <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;ali&quot;</span>))&#123;<br>            <span class="hljs-type">AliPay</span> <span class="hljs-variable">aliPay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliPay</span>();<br>            aliPay.pay();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type.equals(<span class="hljs-string">&quot;wx&quot;</span>))&#123;<br>            <span class="hljs-type">WXPay</span> <span class="hljs-variable">wxPay</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WXPay</span>();<br>            wxPay.pay();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 支付宝支付</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;支付宝支付&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 微信支付</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WXPay</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;微信支付&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上代码中，如果需要增加银联支付，如YLPay,那么就必须要修改DepositPay中的pay方法的源代码，增加新的判断逻辑，违反了开闭原则（对修改关闭，对扩展开放），所以现在必须重构此代码，让其遵循开闭原则，做法如下：</p><p>增加一个接口，使得各种具体支付实现其接口DepositPay类针对接口编程，由客户端来决定具体使用哪种支付方式<br><img src="http://oss.randallstevens.top/DesignPriciple_2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Pay</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span> &#123;<br>     .....<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WXPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span>&#123;<br>     .....<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CardPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pay</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在使用card支付&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 客户端调用-押金支付选择支付手段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DepositPay</span> &#123;<br>    <span class="hljs-comment">//paymode写在配置文件可以直接编辑，且不需要编译，所以一般不认为更改配置文件是更改源码。</span><br>    <span class="hljs-comment">//如果一个系统能做到只需要修改配置文件，无需修改源码，那么复合开闭原则</span><br>    <span class="hljs-meta">@Autowired</span><br>    Pay payMode;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(Pay payMode)</span>&#123;<br>        payMode.pay();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-里式替换原则-LSP"><a href="#3-里式替换原则-LSP" class="headerlink" title="3.里式替换原则 ( LSP )"></a>3.里式替换原则 ( LSP )</h2><p>​    <strong>Liskov Substitution Principle</strong></p><h3 id="里氏替换原则定义"><a href="#里氏替换原则定义" class="headerlink" title="里氏替换原则定义"></a>里氏替换原则定义</h3><blockquote><p>定义一： 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p><p>  第二定义：<strong>子类能够透明地替代父类的功能</strong>        </p></blockquote><p>​        子类可以透明替换父类  =&gt;  表明基类可以复用<br>​        父类无法等价替换子类  =&gt;  子类对父类的功能做了修改，实现，扩充  </p><p>​       实现开闭原则的关键步骤就是抽象化，而子类对基类的可以透明替换就是抽象化（实现复用）的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。</p><h3 id="里氏替换原则实例"><a href="#里氏替换原则实例" class="headerlink" title="里氏替换原则实例"></a><strong>里氏替换原则实例</strong></h3><p>​      java中的实例：Collection接口和其实现类的关系，</p><p>​      某租车系统客户分为普通用户和VIP客户，系统需要提供一个根据邮箱重置密码的功能。原始设计图：</p><p><img src="http://oss.randallstevens.top/DesignPriciple_3.png"></p><p>​     在编写重置密码的时候发现，业务逻辑是一样的，存在着大量的重复代码，而且还可能增加新的用户类型，为了减少代码重复性，使用里氏替换原则进行重构</p><p><img src="http://oss.randallstevens.top/DesignPriciple_4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonCustomer</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Customer</span>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VIPCustomer</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Customer</span>&#123;<br>&#125;<br><span class="hljs-comment">// 重置密码逻辑在这里实现，只需要传入对应的类型即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResetPassword</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resetPassword</span><span class="hljs-params">(Customer customer)</span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>里氏替换原则是实现开闭原则不可或缺的手段之一</code>，<strong>在本例中，通过传递参数使用基类对象，针对抽象编程，从而满足开闭原则。</strong></p><h2 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则  (DIP)"></a>4.依赖倒置原则  (DIP)</h2><p>​    <strong>Dependence Inversion Principle</strong></p><h3 id="依赖倒转原则定义"><a href="#依赖倒转原则定义" class="headerlink" title="依赖倒转原则定义"></a>依赖倒转原则定义</h3><blockquote><p>抽象不应该依赖于细节，细节应当依赖于抽象。即面向接口编程</p></blockquote><p>​     在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。</p><p> 常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入<br><strong>依赖倒转原则实例</strong>：</p><p>​      如OCP原则中的实例各种支付方式依赖pay接口，java中collection接口和实现类</p><h2 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则 (ISP)"></a>5.接口隔离原则 (ISP)</h2><p>​    <strong>Interface Segregation Principle</strong></p><h3 id="接口隔离原则定义"><a href="#接口隔离原则定义" class="headerlink" title="接口隔离原则定义"></a>接口隔离原则定义</h3><blockquote><ol><li>使用多个专门的接口，而不使用单一的总接口，即不应该依赖那些它不需要的接口（最小接口）</li><li>类间的依赖关系应该建立在最小的接口上 </li></ol></blockquote><p>​     一个类实现一个接口时，这个接口中应该只有该类用到的抽象方法，否则就会造成该类仍需实现它所以用不到的方法，造成了接口污染。</p><h3 id="接口隔离原则实例"><a href="#接口隔离原则实例" class="headerlink" title="接口隔离原则实例"></a>接口隔离原则实例</h3><p>接口IAnimal有两个实现类，Bird和Tony,但明显IAnimal中某些方法子类用不到，一次要对接口进行重构</p><p><img src="http://oss.randallstevens.top/DesignPriciple_5.png"></p><p>  接口重构：将接口拆分若干个子接口，按需继承</p><p>​     <img src="http://oss.randallstevens.top/DesignPriciple_6.png"></p><h2 id="6-合成复用原则-CRP"><a href="#6-合成复用原则-CRP" class="headerlink" title="6.合成复用原则 (CRP)"></a>6.合成复用原则 (CRP)</h2><p>​    <strong>Composite Reuse Principle</strong></p><h3 id="合成复用原则定义"><a href="#合成复用原则定义" class="headerlink" title="合成复用原则定义"></a>合成复用原则定义</h3><blockquote><p>通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p></blockquote><p> 在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><p>复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分（属性），新对象可以调用已有对象的功能，它有以下优点。</p><ol><li><p>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</p></li><li><p>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</p></li><li><p>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p><p><strong>合成复用原则实现方式</strong>：构造器注入，属性注入，方法传参   即如spring中依赖注入方式</p></li></ol><h3 id="合成复用原则实例"><a href="#合成复用原则实例" class="headerlink" title="合成复用原则实例"></a>合成复用原则实例</h3><p><img src="http://oss.randallstevens.top/DesignPriciple_7.gif"></p><p>   用继承关系实现会产生很多子类，而且增加新的“动力源”或者增加新的“颜色”都要修改源代码，这违背了开闭原则，显然不可取。但如果改用组合关系实现就能很好地解决以上问题，其类图如图 2 所示。</p><p><img src="http://oss.randallstevens.top/DesignPriciple_8.gif"></p><p>​       Color以属性的形式聚合在类Car中</p><h2 id="7-迪米特法则-最少知道原则-LoD-LKP"><a href="#7-迪米特法则-最少知道原则-LoD-LKP" class="headerlink" title="7.迪米特法则/最少知道原则 (LoD  /LKP)"></a>7.迪米特法则/最少知道原则 (LoD  /LKP)</h2><p>​    <strong>Law of Demeter / Least Knowledge Principle</strong></p><h3 id="迪米特法则定义"><a href="#迪米特法则定义" class="headerlink" title="迪米特法则定义"></a>迪米特法则定义</h3><blockquote><p>一个对象应该对其他对象有最少的理解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被调用或耦合的类）的内部是如何地复杂与我无关，那是你的事情，我就知道你提供了这么多的public方法，我就调用这么多，其他我一概不关心。</p></blockquote><p> 特点：</p><ul><li>只和朋友交流</li></ul><p>​      朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。</p><p> 即不要让陌生类出现在方法中，使用中介的形式与形式与陌生类交流</p><h3 id="迪米特法则实例"><a href="#迪米特法则实例" class="headerlink" title="迪米特法则实例"></a>迪米特法则实例</h3><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="http://oss.randallstevens.top/DesignPriciple_9.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//明星</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Star</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//粉丝</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fans</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//公司</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Company</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//经济人</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Agent</span> &#123;<br>    <span class="hljs-comment">//聚合其他类作为属性</span><br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStar</span><span class="hljs-params">(Star star)</span> &#123;<br>        <span class="hljs-built_in">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFans</span><span class="hljs-params">(Fans fans)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompany</span><span class="hljs-params">(Company company)</span> &#123;<br>        <span class="hljs-built_in">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meeting</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">business</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>​     <strong>SOLID</strong>: 意为 可靠的   是指面向对象的5大设计原则（共有7大原则省略了迪米特和合成复用原则）。寓意着代码使用设计模式也会使得代码变得可靠，强大，具有的健壮性和可重构性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
